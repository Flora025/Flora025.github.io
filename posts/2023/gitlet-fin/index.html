<!DOCTYPE html>
<html translate="no" lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>CS61B Gitlet 完结记录 | EIMY</title>
<meta name="keywords" content="课程">
<meta name="description" content="♪(´ε｀ )">
<meta name="author" content="Flora">
<link rel="canonical" href="http://eimy.ink/posts/2023/gitlet-fin/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.3f09ba765b9df309056d4698ef69e5ff8d1e95c6d19db8f6e8faedc07b090157.css" integrity="sha256-Pwm6dlud8wkFbUaY72nl/40elcbRnbj26PrtwHsJAVc=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f83806d9904cccf883edf075a5ce1d71136879702650d07aca8c76361a3e467b.js" integrity="sha256-&#43;DgG2ZBMzPiD7fB1pc4dcRNoeXAmUNB6yox2Nho&#43;Rns="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="http://eimy.ink/favicons/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://eimy.ink/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://eimy.ink/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://eimy.ink/apple-touch-icon.png">
<link rel="mask-icon" href="http://eimy.ink/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="http://eimy.ink/posts/2023/gitlet-fin/">
<link rel="alternate" hreflang="en" href="http://eimy.ink/en/posts/2023/gitlet-fin/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<meta property="og:title" content="CS61B Gitlet 完结记录" />
<meta property="og:description" content="♪(´ε｀ )" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://eimy.ink/posts/2023/gitlet-fin/" /><meta property="og:image" content="http://eimy.ink/papermod-cover.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-13T00:00:00+00:00" />
<meta property="article:modified_time" content="2023-07-13T00:00:00+00:00" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="http://eimy.ink/papermod-cover.png"/>

<meta name="twitter:title" content="CS61B Gitlet 完结记录"/>
<meta name="twitter:description" content="♪(´ε｀ )"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://eimy.ink/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "CS61B Gitlet 完结记录",
      "item": "http://eimy.ink/posts/2023/gitlet-fin/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "CS61B Gitlet 完结记录",
  "name": "CS61B Gitlet 完结记录",
  "description": "♪(´ε｀ )",
  "keywords": [
    "课程"
  ],
  "articleBody": " 又名：Gitlet in Hindsight: Why I Suggest U Always Read the DON’Ts Part in Spec First\n花了几天补票了61b的知名项目Gitlet——60页重量级spec面面俱到（笑），项目内容自带科普性，覆盖从系统设计到集成测试的每种技术基础普及和训练，不愧是该课史上评价最高的pj。\n【指路】UCB CS61B-21SP-Gitlet\n项目概述 Gitlet是一个版本管理系统，仿照主流系统Git的功能并实现了其部分基本命令，包括init, add, commit, rm, checkout, branch, reset, rm-branch, merge等。\n作为一个课程个人项目，开局仅有几个必要的类.java和几行代码样例，要求根据需求自行设计并完成系统、对象方法、数据结构和少量算法的构造。\nGitlet版本控制原理 Git（let）的版本控制说白了就是「怎么保存某个版本」和「怎么切换到某个版本」的问题。可以从由上至下三个层面理解这两个问题：一是从最上面的用户层面；二是从对象层面；三是从文件读写层面。\n从设计上来说这三层之间应该存在abtraction barrier。也就是说用户使用命令时不需要知道也不能操作对象、指针这些，对象之间也不应该出现文件读写操作。\n用户层面 先是一些上层发生的事情，也就是用户能知道的部分。\ngit初始化干了什么？在当前工作目录（CWD）创建一个.git的隐藏目录目录和里面的一些文件。 怎么保存文件的版本？每次commit时，获取所提交的文件的当前快照（snapshot），并保存在.git中。 怎么切换到指定的版本？使用像是checkout, reset 这样切换版本的命令时，git会根据给定的分支名/commit id等，在.git中查找对应的快照，然后把CWD中指定的文件或是整个目录还原成这个快照的样子。 对象层面 然后再看对象层是如何实现这几个步骤的。gitlet在一定程度上简化了git的目录结构，各个对象少存了一些元数据，但本质不变，就用gitlet举例了。下图里是.gitlet目录的结构示意。\ngitlet的版本控制实现用到了两类的对象：Commit和Blob。 每个Blob对象对应一个文件快照。 每个Commit对象对应一次commit。 怎么利用这些对象记录文件的版本？ 每次把文件加入staging area暂存区（add [file name]）时，会创建一个Blob对象存储当前的文件内容，然后把（文件名: 对应的Blob实例）映射关系丢到暂存区里。 每次commit一些文件时，会创建一个Commit对象，从暂存区把可以提交的映射关系保存进Commit对象中。每个对象里除了索引对以外还会记录其父Commit、时间戳、commit message等。 例子：下图中每个蓝色方块代表一个Commit对象，每个Commit对象中存有一个Map，里面记录了当前commit的文件对应的文件快照。比如Commit 1和Commit 2的Hello.txt都指向Blob 0，这就是说在两次commit时文件内容（快照）没有变化。 怎么实现切换到指定的版本？——移动指针 要让HEAD指针切换到另一个分支branchB的branchHeadCommit，这在对象层就等于：HEAD指针本来指向branchA上的某个Commit对象，现在让它指向另一个branchHeadCommit这个Commit对象。类似updatePointerToCommit(HEAD, branchHeadCommit)。 文件读写层面 最后看更低一层，文件读写层。因为执行一部分命令时要把Blob对象和Commit对象以及暂存区的当前内容存储到本地，这就涉及到两个问题：\n如何对象存成数据（方便后续需要的时候从文件中取出调用）？\n利用Java的序列化（Serialization）。Java里的序列化读写操作：\n在gitlet里，所有对象都是可以序列化存进文件里的，包括Blob、Commit和StagingArea（如有）。在.git里，它们被存放在/.git/objects/目录中。\n而指针变动实际是通过文件读写实现的（不需要序列化）。每个指针都是一个文件，文件里存着它指向的对象的id。在修改指针指向时，实际修改的是文件里的id。在.git里，它们被存放在.git/refs/目录中。\n1 2 3 4 5 6 7 8 9 10 11 /* Serialize a Model object */ Model m = ....; // 可序列化前提：Model类需要implements Serializable File outFile = new File(saveFileName); // 新建File try { ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(outFile)); out.writeObject(m); // 将对象写入steam out.close(); } catch (IOException excp) { ... } 1 2 3 4 5 6 7 8 9 10 11 12 /* Deserialize a Model object */ Model m; File inFile = new File(saveFileName); try { ObjectInputStream inp = new ObjectInputStream(new FileInputStream(inFile)); m = (Model) inp.readObject(); // cast object into expected class inp.close(); } catch (IOException | ClassNotFoundException excp) { ... m = null; } 如何查找并获取对象/修改指针指向？\nGitlet和Git都使用SHA-1（Secure Hash Algorithm 1）加密数据，产生一个160位的哈希值作为当前对象的id（40个十六进制数）。每个对象在创建时会根据自身的内容产生id，比如相同的文件内容经过加密会产生相同的id；并且它们保存的文件名就是它们的id。这意味着通过id就可以在目录中找到对应序列化过的对象。更重要的是，这就允许根据内容寻找文件的地址（content-addressable)。 关于对象获取，以获取Commit对象为例，步骤是：获得commit id（对象在构造时应有id字段） -\u003e 根据id获取文件路径（因为都存放在指定目录下，根据id寻址） -\u003e 反序列化文件。同理，修改就是修改对象内容后，再序列化写入文件。 关于修改指针指向，在文件读写层实际需要完成的操作是：获取targetCommit的id -\u003e 把id写入HEAD指针对应的文件中。 （提醒自己）需要注意的是这些操作都应该封装在对象里，在主逻辑里不该出现commitMap.put(readContentAsString(commitPath), readContentAsString(blobPath))这种东西。写完翻别人实现的时候，看到有人是这样在对象层混用文件读写操作的，达咩。\n小结 以上是三遍不同的废话。版本控制系统类比一下基本就是：\n初始化版本控制系统 == 在当前工作目录放一个小盒子 保存文件的版本 == 每次提交时，把提交的东西拷一份存档放盒子里 切换当前目录/目录中某个文件到某个版本 == 在盒子里找对应的存档，拿出来放在CWD 其余的对象、指针和编码等等方式，都是用来精简每次拷贝的东西、加快盒子里找东西的速度的tricks（至少我是这么理解）：\nBlob对象 == 一个文件的存档 Commit对象 == 一张记录哪个时候该找哪个文件版本的小抄 Commit tree == 小抄们的目录大纲 SHA-1编码 == 给每个文件按照他们的内容起名（在快速对比文件内容、寻址上都有用） 指针 == 写着现在盒子里是哪个版本的标签 暴力存档谁都会（试想：paper_final_final_final.docx)，要说的话，我觉得精髓在于sha-1。\n思考 边写代码边记录的，比较乱\n关于spec阅读顺序 gitlet的项目说明很长，一次读完再开始不现实。如果再写一次，我会先看视频+扫读所有commands说明和avoids事项，然后边写边看。 spec里的「注意不要xxx」部分要仔细看，之所以写上去是因为大家真的会这样做，比如默认Map都是HashMap然后写出Heisenbug，实际为了维护顺序应该用TreeMap。←callback开头 关于设计 一开始需要整体地阅读spec，明确每个对象的作用和它们之间的常用交互方法，设计好了再开始实现。\n正面案例：在写命令的时候准备大改目录，但因为前面abstraction设计得还不错，除了File目录加一句以外什么都不需要改。\n保护abstraction barrier。上层对象之间的交互一定要避免使用底层操作。\n反面案例：前期直接在主逻辑里完成hashing、序列化，中间为了封装重构改了好久\n起名很重要。经过血的教训总结以下几点：\n统一性–就像数据表连接一样，既然对象之间需要通信，那它们一定有一些共通的名字。反面案例就像是我一开始干的，把sha-1 hash得到的id，在不同类里写成shaName、shaId、hashName… 直观性–变量名越具体越好，比如map可以写出keyToVal，不然想起来费劲 泛用性–方法最好不要太具体，这样再别处调用的时候也能想起来。比如getHead getMaster就可以写成getCommit/getPointer。 其他 可以读下git的源码寻找better practice，虽然只看spec也基本够用。 数据 time and space 代码总行数大约1k；时间上大概花了4.5天，wakatime统计的用时是40小时左右，虽然里面十多个小时在debug（。）这方面我记得Josh课上有分享同学的数据，大部分人完成时间也差不多是30-40hrs。\n从统计上看gitlet体量不大，不过考虑到它要求独立完成且涉及到了设计、单元和集成测试、makefile、java file i/o、算法、编码、甚至git本身的训练，还是非常rewarding的。\nAutograder情况 通过了所有功能性测试。Fail的几个Extra-Credit，style (mainly naming，下次一定)和迟交我认为无伤大雅，就没有继续面向autograder编程。\n没有写EC的原因：1）到了后期很多指令都是组合前面的指令，边际效益低；2）gitlet中的remote指令和git相去甚远，不见得有助于学习git的底层逻辑；3）在de了一个Heisenbug以后心力憔悴。\n感想 Gitlet是一款我的世界名校震撼.jpg 就像开头吹的一样，我坚信大部分水平和我类似的人都能通过这个project收获很多，具体只要看一眼spec就知道了。\n技术上我太菜也没资格说什么，只能最后讲几句别的。Josh在不记得哪节课上分享过Gitlet的survey结果，印象深刻的是有一部分学生在这个pj上花了50+小时（就我个人经历，这远超出正常大一的一门课的一个课设的workload），但是最后给了负面评价的只有寥寥几人，Josh好像还单独拿出来表示抱歉了。从侧面反映了The Gitlet Grind的价值。\n61B至此完结，感恩开源！继续肝别的去咯\n附录 以下是从写的readme中转载的my gitlet设计方面的说明\nDesign Abstraction Principle An issue with version control systems:\nRequires cumbersome operations like hashing, serialization, map operations, directory concatenation, file I/O, etc.\nSolution:\nOn a higher level, involve only communications between objects (between Blob and Commit, there should only be Blob b = commit1.get(filename)) Eliminate the need to dive into low-level operations through encapsulation. i.e. Outside the class of that object, never try to hash things, or modify maps inside Commit/Blob objects. E.g. The StagingArea supports common map operations. Upon put (fileName, Commit), it completes: read commit into commit id -\u003e put into its map -\u003e serialize itself and write into the file for staging. Persistence The directory structure looks like this:\n1 2 3 4 5 6 7 8 9 10 CWD └──.gitlet └── --commits/ # all commits ├──blobs/ # file content ├──branchHeads/ # branch heads | └──--master # master branch | ├──..\t# other branches ├──HEAD\t# HEAD commit ├──add # staging area for addition └──rm # staging area for removal The Main class is the entry class of the project. It is responsible for calling different functions according to given commands.\nThe Repository class will set up all persistance. It will\nCreate and initialize files and directories in the .gitlet folder if the directory does not exist; Handle all updates of HEAD , master, branchHeads and the serialization of two StagingAreas add and rm. Execute the commands / function calls from Main. The Commit class handles the serialization of Commit objects. It also deals with conversion between commit ids and commit objects. Each Commit records mappings of held file names and their corresponding file content. Specifically, it fulfil the following purposes:\nConstructs Commit objects; Serializes and saves Commit objects to the .gitlet/commits directory; Given a commit id, retrieves the corresponding Commit object. The Blob class handles the serialization of Blob objects. A blob is a snapshot of a file’s content at the moment of addition. For instance, a file named “hello.txt” can refer to different Blobs in different Commits.\nIts functions are similar to Commit, namely object construction, serialization and retrieval.\nThe StagingArea class stores files for addition and removal. A StagingArea works like a Java Map, stores mappings of file plain names to their blob ids, and supports basic map operations (remove, get, put). add and rm are StagingAreas for staged addition and removal respectively.\n",
  "wordCount" : "650",
  "inLanguage": "zh",
  "datePublished": "2023-07-13T00:00:00Z",
  "dateModified": "2023-07-13T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Flora"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://eimy.ink/posts/2023/gitlet-fin/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "EIMY",
    "logo": {
      "@type": "ImageObject",
      "url": "http://eimy.ink/favicons/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://eimy.ink/" accesskey="h" title="EIMY (Alt + H)">EIMY</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                    <li>
                        <a href="http://eimy.ink/en/" title="English"
                            aria-label="English">English</a>
                    </li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://eimy.ink/archives" title="归档">
                    <span>归档</span>
                </a>
            </li>
            <li>
                <a href="http://eimy.ink/categories/" title="分类">
                    <span>分类</span>
                </a>
            </li>
            <li>
                <a href="http://eimy.ink/tags/" title="标签">
                    <span>标签</span>
                </a>
            </li>
            <li>
                <a href="http://eimy.ink/search/" title="搜索">
                    <span>搜索</span>
                </a>
            </li>
            <li>
                <a href="http://eimy.ink/about/" title="关于">
                    <span>关于</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main post">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://eimy.ink/">主页</a>&nbsp;»&nbsp;<a href="http://eimy.ink/posts/">Posts</a></div>
    <h1 class="post-title">
      CS61B Gitlet 完结记录
    </h1>
    <div class="post-meta"><span title='2023-07-13 00:00:00 +0000 UTC'>七月 13, 2023</span>&nbsp;·&nbsp;Flora&nbsp;|&nbsp;语言:
<ul class="i18n_list">
    <li>
        <a href="http://eimy.ink/en/posts/2023/gitlet-fin/">English</a>
    </li>
</ul>

</div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">目录</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#%e9%a1%b9%e7%9b%ae%e6%a6%82%e8%bf%b0" aria-label="项目概述">项目概述</a></li>
                    <li>
                        <a href="#gitlet%e7%89%88%e6%9c%ac%e6%8e%a7%e5%88%b6%e5%8e%9f%e7%90%86" aria-label="Gitlet版本控制原理">Gitlet版本控制原理</a><ul>
                            
                    <li>
                        <a href="#%e7%94%a8%e6%88%b7%e5%b1%82%e9%9d%a2" aria-label="用户层面">用户层面</a></li>
                    <li>
                        <a href="#%e5%af%b9%e8%b1%a1%e5%b1%82%e9%9d%a2" aria-label="对象层面">对象层面</a></li>
                    <li>
                        <a href="#%e6%96%87%e4%bb%b6%e8%af%bb%e5%86%99%e5%b1%82%e9%9d%a2" aria-label="文件读写层面">文件读写层面</a></li>
                    <li>
                        <a href="#%e5%b0%8f%e7%bb%93" aria-label="小结">小结</a></li></ul>
                    </li>
                    <li>
                        <a href="#%e6%80%9d%e8%80%83" aria-label="思考">思考</a><ul>
                            
                    <li>
                        <a href="#%e5%85%b3%e4%ba%8espec%e9%98%85%e8%af%bb%e9%a1%ba%e5%ba%8f" aria-label="关于spec阅读顺序">关于spec阅读顺序</a></li>
                    <li>
                        <a href="#%e5%85%b3%e4%ba%8e%e8%ae%be%e8%ae%a1" aria-label="关于设计">关于设计</a></li>
                    <li>
                        <a href="#%e5%85%b6%e4%bb%96" aria-label="其他">其他</a></li></ul>
                    </li>
                    <li>
                        <a href="#%e6%95%b0%e6%8d%ae" aria-label="数据">数据</a><ul>
                            
                    <li>
                        <a href="#time-and-space" aria-label="time and space">time and space</a></li>
                    <li>
                        <a href="#autograder%e6%83%85%e5%86%b5" aria-label="Autograder情况">Autograder情况</a></li></ul>
                    </li>
                    <li>
                        <a href="#%e6%84%9f%e6%83%b3" aria-label="感想">感想</a></li>
                    <li>
                        <a href="#%e9%99%84%e5%bd%95" aria-label="附录">附录</a><ul>
                            
                    <li>
                        <a href="#design" aria-label="Design">Design</a><ul>
                            
                    <li>
                        <a href="#abstraction-principle" aria-label="Abstraction Principle">Abstraction Principle</a></li>
                    <li>
                        <a href="#persistence" aria-label="Persistence">Persistence</a>
                    </li>
                </ul>
                </li>
                </ul>
                </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>

  <div class="post-content"><blockquote>
<p>又名：Gitlet in Hindsight: Why I Suggest U Always Read the DON&rsquo;Ts Part in Spec First</p>
</blockquote>
<p>花了几天补票了61b的知名项目Gitlet——60页重量级spec面面俱到（笑），项目内容自带科普性，覆盖从系统设计到集成测试的每种技术基础普及和训练，不愧是该课史上评价最高的pj。</p>
<p>【指路】<a href="https://sp21.datastructur.es/materials/proj/proj2/proj2">UCB CS61B-21SP-Gitlet</a></p>
<h2 id="项目概述">项目概述<a hidden class="anchor" aria-hidden="true" href="#项目概述">#</a></h2>
<p>Gitlet是一个版本管理系统，仿照主流系统Git的功能并实现了其部分基本命令，包括<code>init</code>, <code>add</code>, <code>commit</code>, <code>rm</code>, <code>checkout</code>, <code>branch</code>, <code>reset</code>, <code>rm-branch</code>, <code>merge</code>等。</p>
<p>作为一个课程个人项目，开局仅有几个必要的类.java和几行代码样例，要求根据需求自行设计并完成系统、对象方法、数据结构和少量算法的构造。</p>
<h2 id="gitlet版本控制原理">Gitlet版本控制原理<a hidden class="anchor" aria-hidden="true" href="#gitlet版本控制原理">#</a></h2>
<p>Git（let）的版本控制说白了就是「怎么保存某个版本」和「怎么切换到某个版本」的问题。可以从由上至下三个层面理解这两个问题：一是从最上面的用户层面；二是从对象层面；三是从文件读写层面。</p>
<p>从设计上来说这三层之间应该存在<a href="https://en.wikibooks.org/wiki/Object_Oriented_Programming/Abstraction_Barrier">abtraction barrier</a>。也就是说用户使用命令时不需要知道也不能操作对象、指针这些，对象之间也不应该出现文件读写操作。</p>
<h3 id="用户层面">用户层面<a hidden class="anchor" aria-hidden="true" href="#用户层面">#</a></h3>
<p>先是一些上层发生的事情，也就是用户能知道的部分。</p>
<ul>
<li>git初始化干了什么？在当前工作目录（CWD）创建一个<code>.git</code>的隐藏目录目录和里面的一些文件。</li>
<li>怎么保存文件的版本？每次<code>commit</code>时，获取所提交的文件的当前快照（snapshot），并保存在<code>.git</code>中。</li>
<li>怎么切换到指定的版本？使用像是<code>checkout</code>, <code>reset</code> 这样切换版本的命令时，git会根据给定的分支名/commit id等，在<code>.git</code>中查找对应的快照，然后把CWD中指定的文件或是整个目录还原成这个快照的样子。</li>
</ul>
<img src="./assets/image-20230713140220806.png#center" alt=".git目录" style="zoom:50%;border-radius:5px;" />
<h3 id="对象层面">对象层面<a hidden class="anchor" aria-hidden="true" href="#对象层面">#</a></h3>
<p>然后再看对象层是如何实现这几个步骤的。gitlet在一定程度上简化了git的目录结构，各个对象少存了一些元数据，但本质不变，就用gitlet举例了。下图里是<code>.gitlet</code>目录的结构示意。</p>
<ul>
<li>gitlet的版本控制实现用到了两类的对象：Commit和Blob。
<ul>
<li>每个Blob对象对应一个文件快照。</li>
<li>每个Commit对象对应一次<code>commit</code>。</li>
</ul>
</li>
<li>怎么利用这些对象记录文件的版本？
<ul>
<li>每次把文件加入staging area暂存区（<code>add [file name]</code>）时，会创建一个Blob对象存储当前的文件内容，然后把<code>（文件名: 对应的Blob实例）</code>映射关系丢到暂存区里。</li>
<li>每次<code>commit</code>一些文件时，会创建一个Commit对象，从暂存区把可以提交的映射关系保存进Commit对象中。每个对象里除了索引对以外还会记录其父Commit、时间戳、commit message等。</li>
<li>例子：下图中每个蓝色方块代表一个Commit对象，每个Commit对象中存有一个Map，里面记录了当前commit的文件对应的文件快照。比如Commit 1和Commit 2的Hello.txt都指向Blob 0，这就是说在两次commit时文件内容（快照）没有变化。</li>
</ul>
</li>
<li>怎么实现切换到指定的版本？——移动指针
<ul>
<li>要让<code>HEAD</code>指针切换到另一个分支branchB的<code>branchHeadCommit</code>，这在对象层就等于：<code>HEAD</code>指针本来指向branchA上的某个Commit对象，现在让它指向另一个<code>branchHeadCommit</code>这个Commit对象。类似<code>updatePointerToCommit(HEAD, branchHeadCommit)</code>。</li>
</ul>
</li>
</ul>
<img src="./assets/image-20230707133304171.png#center" alt=".gitlet结构" style="zoom:50%;" />
<h3 id="文件读写层面">文件读写层面<a hidden class="anchor" aria-hidden="true" href="#文件读写层面">#</a></h3>
<p>最后看更低一层，文件读写层。因为执行一部分命令时要把Blob对象和Commit对象以及暂存区的当前内容存储到本地，这就涉及到两个问题：</p>
<ul>
<li>
<p>如何对象存成数据（方便后续需要的时候从文件中取出调用）？</p>
<ul>
<li>
<p>利用Java的序列化（Serialization）。Java里的序列化读写操作：</p>
</li>
<li>
<p>在gitlet里，所有<strong>对象</strong>都是可以序列化存进文件里的，包括Blob、Commit和StagingArea（如有）。在<code>.git</code>里，它们被存放在<code>/.git/objects/</code>目录中。</p>
</li>
<li>
<p>而<strong>指针</strong>变动实际是通过文件读写实现的（不需要序列化）。每个指针都是一个文件，文件里存着它指向的对象的id。在修改指针指向时，实际修改的是文件里的id。在<code>.git</code>里，它们被存放在<code>.git/refs/</code>目录中。</p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="cm">/* Serialize a Model object */</span>
</span></span><span class="line"><span class="cl"><span class="n">Model</span> <span class="n">m</span> <span class="o">=</span> <span class="o">....;</span> <span class="c1">// 可序列化前提：Model类需要implements Serializable
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">File</span> <span class="n">outFile</span> <span class="o">=</span> <span class="k">new</span> <span class="n">File</span><span class="o">(</span><span class="n">saveFileName</span><span class="o">);</span> <span class="c1">// 新建File
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">try</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">ObjectOutputStream</span> <span class="n">out</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">        <span class="k">new</span> <span class="n">ObjectOutputStream</span><span class="o">(</span><span class="k">new</span> <span class="n">FileOutputStream</span><span class="o">(</span><span class="n">outFile</span><span class="o">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">out</span><span class="o">.</span><span class="na">writeObject</span><span class="o">(</span><span class="n">m</span><span class="o">);</span> <span class="c1">// 将对象写入steam
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">out</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">IOException</span> <span class="n">excp</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">...</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="cm">/* Deserialize a Model object */</span>
</span></span><span class="line"><span class="cl"><span class="n">Model</span> <span class="n">m</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="n">File</span> <span class="n">inFile</span> <span class="o">=</span> <span class="k">new</span> <span class="n">File</span><span class="o">(</span><span class="n">saveFileName</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="k">try</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">ObjectInputStream</span> <span class="n">inp</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">        <span class="k">new</span> <span class="n">ObjectInputStream</span><span class="o">(</span><span class="k">new</span> <span class="n">FileInputStream</span><span class="o">(</span><span class="n">inFile</span><span class="o">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">m</span> <span class="o">=</span> <span class="o">(</span><span class="n">Model</span><span class="o">)</span> <span class="n">inp</span><span class="o">.</span><span class="na">readObject</span><span class="o">();</span>  <span class="c1">// cast object into expected class
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">inp</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">IOException</span> <span class="o">|</span> <span class="n">ClassNotFoundException</span> <span class="n">excp</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">...</span>
</span></span><span class="line"><span class="cl">    <span class="n">m</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>如何查找并获取对象/修改指针指向？</p>
<ul>
<li>Gitlet和Git都使用SHA-1（Secure Hash Algorithm 1）加密数据，产生一个160位的哈希值作为当前对象的id（40个十六进制数）。每个对象在创建时会<strong>根据自身的内容</strong>产生id，比如<strong>相同的文件内容经过加密会产生相同的id</strong>；并且它们保存的文件名就是它们的id。这意味着通过id就可以在目录中找到对应序列化过的对象。更重要的是，这就允许<strong>根据内容寻找文件的地址</strong>（content-addressable)。</li>
<li>关于<strong>对象</strong>获取，以获取Commit对象为例，步骤是：获得commit id（对象在构造时应有id字段） -&gt; 根据id获取文件路径（因为都存放在指定目录下，根据id寻址） -&gt; 反序列化文件。同理，修改就是修改对象内容后，再序列化写入文件。</li>
<li>关于修改<strong>指针</strong>指向，在文件读写层实际需要完成的操作是：获取targetCommit的id -&gt; 把id写入HEAD指针对应的文件中。</li>
</ul>
</li>
</ul>
<p>（提醒自己）需要注意的是这些操作都应该封装在对象里，在主逻辑里不该出现<code>commitMap.put(readContentAsString(commitPath), readContentAsString(blobPath))</code>这种东西。写完翻别人实现的时候，看到有人是这样在对象层混用文件读写操作的，达咩。</p>
<h3 id="小结">小结<a hidden class="anchor" aria-hidden="true" href="#小结">#</a></h3>
<p>以上是三遍不同的废话。版本控制系统类比一下基本就是：</p>
<ul>
<li>初始化版本控制系统 == 在当前工作目录放一个小盒子</li>
<li>保存文件的版本 == 每次提交时，把提交的东西拷一份存档放盒子里</li>
<li>切换当前目录/目录中某个文件到某个版本 == 在盒子里找对应的存档，拿出来放在CWD</li>
</ul>
<p>其余的对象、指针和编码等等方式，都是用来精简每次拷贝的东西、加快盒子里找东西的速度的tricks（至少我是这么理解）：</p>
<ul>
<li>Blob对象 == 一个文件的存档</li>
<li>Commit对象 == 一张记录哪个时候该找哪个文件版本的小抄</li>
<li>Commit tree == 小抄们的目录大纲</li>
<li>SHA-1编码 == 给每个文件按照他们的内容起名（在快速对比文件内容、寻址上都有用）</li>
<li>指针 == 写着现在盒子里是哪个版本的标签</li>
</ul>
<p>暴力存档谁都会（试想：paper_final_final_final.docx)，要说的话，我觉得精髓在于sha-1。</p>
<h2 id="思考">思考<a hidden class="anchor" aria-hidden="true" href="#思考">#</a></h2>
<blockquote>
<p>边写代码边记录的，比较乱</p>
</blockquote>
<h3 id="关于spec阅读顺序">关于spec阅读顺序<a hidden class="anchor" aria-hidden="true" href="#关于spec阅读顺序">#</a></h3>
<ul>
<li>gitlet的项目说明很长，一次读完再开始不现实。如果再写一次，我会先看视频+扫读所有commands说明和avoids事项，然后边写边看。</li>
<li>spec里的「注意不要xxx」部分要仔细看，之所以写上去是因为大家真的会这样做，比如默认Map都是HashMap然后写出Heisenbug，实际为了维护顺序应该用TreeMap。←callback开头</li>
</ul>
<h3 id="关于设计">关于设计<a hidden class="anchor" aria-hidden="true" href="#关于设计">#</a></h3>
<ul>
<li>
<p>一开始需要整体地阅读spec，明确每个对象的作用和它们之间的常用交互方法，设计好了再开始实现。</p>
<p>正面案例：在写&lt;branch&gt;命令的时候准备大改目录，但因为前面abstraction设计得还不错，除了File目录加一句以外什么都不需要改。</p>
</li>
<li>
<p>保护abstraction barrier。上层对象之间的交互一定要避免使用底层操作。</p>
<p>反面案例：前期直接在主逻辑里完成hashing、序列化，中间为了封装重构改了好久</p>
</li>
<li>
<p>起名很重要。经过血的教训总结以下几点：</p>
<ul>
<li>统一性&ndash;就像数据表连接一样，既然对象之间需要通信，那它们一定有一些共通的名字。反面案例就像是我一开始干的，把sha-1 hash得到的id，在不同类里写成shaName、shaId、hashName&hellip;</li>
<li>直观性&ndash;变量名越具体越好，比如map可以写出keyToVal，不然想起来费劲</li>
<li>泛用性&ndash;方法最好不要太具体，这样再别处调用的时候也能想起来。比如getHead getMaster就可以写成getCommit/getPointer。</li>
</ul>
</li>
</ul>
<h3 id="其他">其他<a hidden class="anchor" aria-hidden="true" href="#其他">#</a></h3>
<ul>
<li>可以读下git的源码寻找better practice，虽然只看spec也基本够用。</li>
</ul>
<h2 id="数据">数据<a hidden class="anchor" aria-hidden="true" href="#数据">#</a></h2>
<h3 id="time-and-space">time and space<a hidden class="anchor" aria-hidden="true" href="#time-and-space">#</a></h3>
<p>代码总行数大约1k；时间上大概花了4.5天，wakatime统计的用时是40小时左右，虽然里面十多个小时在debug（。）这方面我记得Josh课上有分享同学的数据，大部分人完成时间也差不多是30-40hrs。</p>
<p>从统计上看gitlet体量不大，不过考虑到它要求独立完成且涉及到了设计、单元和集成测试、makefile、java file i/o、算法、编码、甚至git本身的训练，还是非常rewarding的。</p>
<img src="./assets/image-20230712171416829.png#center" alt="code stats" style="zoom:50%;" />
<h3 id="autograder情况">Autograder情况<a hidden class="anchor" aria-hidden="true" href="#autograder情况">#</a></h3>
<p>通过了所有功能性测试。Fail的几个Extra-Credit，style (mainly naming，下次一定)和迟交我认为无伤大雅，就没有继续面向autograder编程。</p>
<p>没有写EC的原因：1）到了后期很多指令都是组合前面的指令，边际效益低；2）gitlet中的remote指令和git相去甚远，不见得有助于学习git的底层逻辑；3）在de了一个Heisenbug以后心力憔悴。</p>
<img src="./assets/image-20230712170907514.png#center" alt="Autograder: passed all functional tests" style="zoom:50%;" />
<h2 id="感想">感想<a hidden class="anchor" aria-hidden="true" href="#感想">#</a></h2>
<p>Gitlet是一款我的世界名校震撼.jpg 就像开头吹的一样，我坚信大部分水平和我类似的人都能通过这个project收获很多，具体只要看一眼spec就知道了。</p>
<p>技术上我太菜也没资格说什么，只能最后讲几句别的。Josh在不记得哪节课上分享过Gitlet的survey结果，印象深刻的是有一部分学生在这个pj上花了50+小时（就我个人经历，这远超出正常大一的一门课的一个课设的workload），但是最后给了负面评价的只有寥寥几人，Josh好像还单独拿出来表示抱歉了。从侧面反映了The Gitlet Grind的价值。</p>
<p>61B至此完结，感恩开源！继续肝别的去咯</p>
<h2 id="附录">附录<a hidden class="anchor" aria-hidden="true" href="#附录">#</a></h2>
<blockquote>
<p>以下是从写的readme中转载的my gitlet设计方面的说明</p>
</blockquote>
<h3 id="design">Design<a hidden class="anchor" aria-hidden="true" href="#design">#</a></h3>
<h4 id="abstraction-principle">Abstraction Principle<a hidden class="anchor" aria-hidden="true" href="#abstraction-principle">#</a></h4>
<ul>
<li>
<p>An issue with version control systems:</p>
<p>Requires cumbersome operations like hashing, serialization, map operations, directory concatenation, file I/O, etc.</p>
</li>
<li>
<p>Solution:</p>
<ul>
<li>On a higher level, involve only communications between objects (between Blob and Commit, there should only be <code>Blob b = commit1.get(filename)</code>)</li>
<li>Eliminate the need to dive into low-level operations through encapsulation.
i.e. Outside the class of that object, never try to hash things, or modify maps inside Commit/Blob objects.
E.g. The <code>StagingArea</code> supports common map operations. Upon put (fileName, Commit), it completes: read commit into commit id -&gt; put into its map -&gt; serialize itself and write into the file for staging.</li>
</ul>
</li>
</ul>
<h4 id="persistence">Persistence<a hidden class="anchor" aria-hidden="true" href="#persistence">#</a></h4>
<p>The directory structure looks like this:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">CWD
</span></span><span class="line"><span class="cl"> └──.gitlet
</span></span><span class="line"><span class="cl">     └── --commits/       <span class="c1"># all commits</span>
</span></span><span class="line"><span class="cl">        ├──blobs/         <span class="c1"># file content</span>
</span></span><span class="line"><span class="cl">        ├──branchHeads/   <span class="c1"># branch heads</span>
</span></span><span class="line"><span class="cl">        <span class="p">|</span>  └──--master      <span class="c1"># master branch</span>
</span></span><span class="line"><span class="cl">        <span class="p">|</span>    ├──..	      <span class="c1"># other branches</span>
</span></span><span class="line"><span class="cl">        ├──HEAD	          <span class="c1"># HEAD commit</span>
</span></span><span class="line"><span class="cl">        ├──add            <span class="c1"># staging area for addition</span>
</span></span><span class="line"><span class="cl">        └──rm             <span class="c1"># staging area for removal</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>The <code>Main</code> class is the entry class of the project. It is responsible for calling different functions according to given commands.</p>
<p>The <code>Repository</code> class will set up all persistance. It will</p>
<ol>
<li>Create and initialize files and directories in the <code>.gitlet</code> folder if the directory does not exist;</li>
<li>Handle all updates of <code>HEAD</code> , <code>master</code>, <code>branchHeads</code> and the serialization of two StagingAreas <code>add</code> and <code>rm</code>.</li>
<li>Execute the commands / function calls from <code>Main</code>.</li>
</ol>
<p>The <code>Commit</code> class handles the serialization of <code>Commit</code> objects. It also deals with conversion between commit ids and commit objects. Each <code>Commit</code> records mappings of held file names and their corresponding file content. Specifically, it fulfil the following purposes:</p>
<ol>
<li>Constructs Commit objects;</li>
<li>Serializes and saves Commit objects to the .gitlet/commits directory;</li>
<li>Given a commit id, retrieves the corresponding Commit object.</li>
</ol>
<p>The <code>Blob</code> class handles the serialization of <code>Blob</code> objects. A blob is a snapshot of a file&rsquo;s content at the moment of addition. For instance, a file named &ldquo;hello.txt&rdquo; can refer to different <code>Blobs</code> in different <code>Commits</code>.</p>
<p>Its functions are similar to <code>Commit</code>, namely object construction, serialization and retrieval.</p>
<p>The <code>StagingArea</code> class stores files for addition and removal. A StagingArea works like a Java Map, stores mappings of file plain names to their blob ids, and supports basic map operations (<code>remove</code>, <code>get</code>, <code>put</code>). <code>add</code> and <code>rm</code> are <code>StagingAreas</code> for staged addition and removal respectively.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://eimy.ink/tags/%E8%AF%BE%E7%A8%8B/">课程</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="http://eimy.ink/posts/2023/aws-amplify/">
    <span class="title">« 上一页</span>
    <br>
    <span>AWS Amplify记录</span>
  </a>
  <a class="next" href="http://eimy.ink/posts/2023/plog-japan-ii/">
    <span class="title">下一页 »</span>
    <br>
    <span>日本中部旅游Plog 2</span>
  </a>
</nav>

  </footer><div id="disqus_thread"></div>
<script>
    
  
    
    var disqus_config = function () {
    this.page.url = "https://Flora025.github.io"; 
    this.page.identifier = hello; 
    };
    
    (function() { 
    var d = document, s = d.createElement('script');
    s.src = 'https://flora025.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2025 <a href="http://eimy.ink/">EIMY</a></span><span style="display: inline-block; margin-left: 1em;">
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/reorx/hugo-PaperMod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
  (function() {
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    const disableSmoothScroll = '' == '1';
    const enableInstantClick = '' == '1';
    
    if (window.matchMedia('(prefers-reduced-motion: reduce)').matches || disableSmoothScroll || enableInstantClick) {
      return;
    }
    
    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                behavior: "smooth"
            });
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });
  })();
</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = '复制';

        function copyingDone() {
            copybutton.innerText = '已复制！';
            setTimeout(() => {
                copybutton.innerText = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
<script>
window.addEventListener('DOMContentLoaded', function (event) {
  const headings = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id]');
  const activeClass = 'active';

  
  let activeHeading = headings[0];
  getLinkByHeading(activeHeading).classList.add(activeClass);

  const onScroll = () => {
    const passedHeadings = [];
    for (const h of headings) {
      
      if (getOffsetTop(h) < 5) {
        passedHeadings.push(h)
      } else {
        break;
      }
    }
    if (passedHeadings.length > 0) {
      newActiveHeading = passedHeadings[passedHeadings.length - 1];
    } else {
      newActiveHeading = headings[0];
    }
    if (activeHeading != newActiveHeading) {
      getLinkByHeading(activeHeading).classList.remove(activeClass);
      activeHeading = newActiveHeading;
      getLinkByHeading(activeHeading).classList.add(activeClass);
    }
  }

  let timer = null;
  window.addEventListener('scroll', () => {
    if (timer !== null) {
      clearTimeout(timer)
    }
    timer = setTimeout(onScroll, 50)
  }, false);

  function getLinkByHeading(heading) {
    const id = encodeURI(heading.getAttribute('id')).toLowerCase();
    return document.querySelector(`.toc ul li a[href="#${id}"]`);
  }

  function getOffsetTop(heading) {
    if (!heading.getClientRects().length) {
      return 0;
    }
    let rect = heading.getBoundingClientRect();
    return rect.top
  }
}, false);
</script></body>

</html>
