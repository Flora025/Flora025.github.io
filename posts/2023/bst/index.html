<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>61B Notes - ADT and BST | FloraZ</title>
<meta name="keywords" content="data structure">
<meta name="description" content="ヽ(´o｀；">
<meta name="author" content="Flora">
<link rel="canonical" href="http://flora025.github.io/posts/2023/bst/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.31d4ca0b0f0c25b30a5eeb159f350b1d5571601bc987f2d9189fa51d953169d0.css" integrity="sha256-MdTKCw8MJbMKXusVnzULHVVxYBvJh/LZGJ&#43;lHZUxadA=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f83806d9904cccf883edf075a5ce1d71136879702650d07aca8c76361a3e467b.js" integrity="sha256-&#43;DgG2ZBMzPiD7fB1pc4dcRNoeXAmUNB6yox2Nho&#43;Rns="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="http://flora025.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://flora025.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://flora025.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://flora025.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="http://flora025.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="http://flora025.github.io/zh/posts/2023/bst/">
<link rel="alternate" hreflang="en" href="http://flora025.github.io/posts/2023/bst/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" integrity="sha384-GvrOXuhMATgEsSwCs4smul74iXGOixntILdUW9XmUC6+HX0sLNAK3q71HotJqlAn" crossorigin="anonymous">


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js" integrity="sha384-cpW21h6RZv/phavutF+AuVYrr+dA8xD9zs6FwLpaCct6O9ctzYFfFr4dgmgccOTx" crossorigin="anonymous"></script>


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>

    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "$$", right: "$$", display: true},
                    {left: "$", right: "$", display: false}
                ]
            });
        });
    </script><meta property="og:title" content="61B Notes - ADT and BST" />
<meta property="og:description" content="ヽ(´o｀；" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://flora025.github.io/posts/2023/bst/" /><meta property="og:image" content="http://flora025.github.io/papermod-cover.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-27T22:36:43+08:00" />
<meta property="article:modified_time" content="2023-03-27T22:36:43+08:00" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="http://flora025.github.io/papermod-cover.png"/>

<meta name="twitter:title" content="61B Notes - ADT and BST"/>
<meta name="twitter:description" content="ヽ(´o｀；"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://flora025.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "61B Notes - ADT and BST",
      "item": "http://flora025.github.io/posts/2023/bst/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "61B Notes - ADT and BST",
  "name": "61B Notes - ADT and BST",
  "description": "ヽ(´o｀；",
  "keywords": [
    "data structure"
  ],
  "articleBody": "Note: The passage is originally written in Chinese and translated into English via ChatGPT.\nReference: Lecture slides from 19sp.\nTrees First, the concept of abstract data type (ADT) is introduced, followed by a progressive/step-by-step optimization-based introduction to three types of trees (BST, B-Tree, LLRB).\nThe notes are divided into two parts, and this article only covers ADT and BST.\nAbstract Data Types (ADT) An abstract data type is defined by its operations, not implementations. Hierarchy Examples ADT Deque; DisjointSets Implementations of ADT ArrayDeque, LinkedListDeque;\nQuickFindDS, WeightedQuickUnionDS Operations of ADT size(), get(), addFirst(Item x), etc. Among the most important interfaces in the java.util library are those that extend the Collection interface. The relationship is shown in the figure. List Set Map The focus this time is on two tree-related data types, TreeSet and TreeMap. Binary Search Tree Origins of BST Question: How can we improve a linked list to perform searches more efficiently?\nThe answer is: 1) Set the entry point in the middle instead of one end. 2) Traverse from the middle to both ends. 3) Traverse in a skipping manner (as shown in the figure).\nDefinition and Properties of BST A binary search tree is a rooted binary tree with the BST property. Tree properties: A set of nodes One path between any two nodes Rooted tree properties: Each node, except the root, has only one parent node. The root is typically drawn at the top. For binary trees, each node can have 0/1/2 child nodes. BST properties: Ordering: Every key in the left subtree is less than X’s key. Every key in the right subtree is greater than X’s key. No duplicate keys are allowed. (Encountering a BST)\nBST Operations Three operations of BST are introduced.\nSearch / Find Code Implementation (It’s easier to understand through the code.) Compare searchKey with T.key –\u003e Found! / searchKey is smaller, search T.left / searchKey is larger, search T.right.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // reference: Algorithms, p.399 /** Return value associated with key in the subtree rooted at x; * return null if key not present in subtree rooted at x. */ public Value get(Key key) { return get(root, key); } private Value get(Node x, Key key) { // helper if (x == null) return null; int cmp = key.compareTo(x.key); if (cmp \u003c 0) { return get(x.left, key); } else if (cmp \u003e 0) { return get(x.right, key); } else { return x.val; } } Runtime Analysis Worst-case runtime: $\\Theta(\\log{N})$ for a dense binary tree. Tree height: ~$\\log_2{(N)}$ Consider the fact that each additional level requires twice the number of nodes. Insert Code Implementation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /** Search for key. Update value if found; grow table if new. */ public void put(Key key, Value val) { root = put(root, key, val); } /** Change key's value to val if key in subtree rooted at x. * Otherwise, add a new node to the subtree associating key with val. */ private Node put(Node x, Key key, Value val) { if (x == null) return new Node(key, val, 1); int cmp = key.compareTo(x.key); // compare searchKey to curKey if (cmp \u003c 0) { x.left = put(x.left, key, val); } else if (cmp \u003e 0) { x.right = put(x.right, key, val); } else { x.val = val; } x.N = size(x.left) + size(x.right) + 1; return x; } Runtime Analysis for Insertion It should be the same as the search operation.\nDelete There are three cases for deletion:\nThe key to be deleted has no child nodes (–\u003e see “glut,” simply disconnect). The key to be deleted has one child node (–\u003e see “flat,” update the parent node’s pointer to the child node). The key to be deleted has two child nodes (as shown in the figure, find the predecessor or successor to replace its position). Code Implementation (p.411) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 private Node min(Node x) { // Find the smallest node and its child nodes under x if (x.left == null) return x; return min(x.left); } public void deleteMin() { // Return the root after deleting the smallest node root = deleteMin(root); } private Node deleteMin(Node x) { // DeleteMin helper if (x.left == null) return x.right; x.left = deleteMin(x.left); x.N = size(x.left) + size(x.right) + 1; return x; } public void delete(Key key) { root = delete(root, key); } private Node delete(Node x, Key key) { if (x == null) return null; int cmp = key.compareTo(x.key); if (cmp \u003c 0) { x.left = delete(x.left, key); } else if (cmp \u003e 0) { x.right = delete(x.right, key); } else { // Assume the node P to be deleted has been found if (x.right == null) return x.left; // Check if P has sub-nodes, A) if it has 0/1 sub-nodes, return it if (x.left == null) return x.right; Node t = x; // B) if it has 2 nodes, the tree needs to be adjusted x = min(t.right); // 1. Find the new substitute for the deleted node P x.right = deleteMin(t.right); // 2. Connect the updated right nodes to the new P x.left = t.left; // 3. Connect the original left sub-nodes to the new P // Note the order matters here! } x .N = size(x.left) + size(x.right) + 1; return x; } Runtime Analysis It should be of the same order as the previous operations since it only involves additional modification steps.\nBSTSet v.s. BSTMap This part introduces Lab9 BSTmap.\nBSTSet and BSTMap have the same structure (a tree), but the difference is that each node is represented using a map (as shown in the figure).\n",
  "wordCount" : "995",
  "inLanguage": "en",
  "datePublished": "2023-03-27T22:36:43+08:00",
  "dateModified": "2023-03-27T22:36:43+08:00",
  "author":{
    "@type": "Person",
    "name": "Flora"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://flora025.github.io/posts/2023/bst/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "FloraZ",
    "logo": {
      "@type": "ImageObject",
      "url": "http://flora025.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://flora025.github.io/" accesskey="h" title="FloraZ (Alt + H)">FloraZ</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                    <li>
                        <a href="http://flora025.github.io/zh/" title="中文"
                            aria-label="中文">中文</a>
                    </li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://flora025.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="http://flora025.github.io/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="http://flora025.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="http://flora025.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="http://flora025.github.io/about/" title="About">
                    <span>About</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main post">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://flora025.github.io/">Home</a>&nbsp;»&nbsp;<a href="http://flora025.github.io/posts/">Posts</a></div>
    <h1 class="post-title">
      61B Notes - ADT and BST
    </h1>
    <div class="post-meta"><span title='2023-03-27 22:36:43 +0800 CST'>March 27, 2023</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Flora&nbsp;|&nbsp;Translations:
<ul class="i18n_list">
    <li>
        <a href="http://flora025.github.io/zh/posts/2023/bst/">中文</a>
    </li>
</ul>

</div>
  </header> <div class="toc side">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#trees" aria-label="Trees">Trees</a><ul>
                        
                <li>
                    <a href="#abstract-data-types-adt" aria-label="Abstract Data Types (ADT)">Abstract Data Types (ADT)</a></li>
                <li>
                    <a href="#binary-search-tree" aria-label="Binary Search Tree">Binary Search Tree</a><ul>
                        
                <li>
                    <a href="#origins-of-bst" aria-label="Origins of BST">Origins of BST</a></li>
                <li>
                    <a href="#definition-and-properties-of-bst" aria-label="Definition and Properties of BST">Definition and Properties of BST</a></li>
                <li>
                    <a href="#bst-operations" aria-label="BST Operations">BST Operations</a><ul>
                        
                <li>
                    <a href="#search--find" aria-label="Search / Find">Search / Find</a><ul>
                        
                <li>
                    <a href="#code-implementation" aria-label="Code Implementation">Code Implementation</a></li>
                <li>
                    <a href="#runtime-analysis" aria-label="Runtime Analysis">Runtime Analysis</a></li></ul>
                </li>
                <li>
                    <a href="#insert" aria-label="Insert">Insert</a><ul>
                        
                <li>
                    <a href="#code-implementation-1" aria-label="Code Implementation">Code Implementation</a></li>
                <li>
                    <a href="#runtime-analysis-for-insertion" aria-label="Runtime Analysis for Insertion">Runtime Analysis for Insertion</a></li></ul>
                </li>
                <li>
                    <a href="#delete" aria-label="Delete">Delete</a><ul>
                        
                <li>
                    <a href="#code-implementation-p411" aria-label="Code Implementation (p.411)">Code Implementation (p.411)</a></li>
                <li>
                    <a href="#runtime-analysis-1" aria-label="Runtime Analysis">Runtime Analysis</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#bstset-vs-bstmap" aria-label="BSTSet v.s. BSTMap">BSTSet v.s. BSTMap</a>
                </li>
            </ul>
            </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>Note: The passage is originally written in Chinese and translated into English via ChatGPT.</p>
<hr>
<p>Reference: Lecture slides from 19sp.</p>
<h1 id="trees">Trees<a hidden class="anchor" aria-hidden="true" href="#trees">#</a></h1>
<p>First, the concept of abstract data type (ADT) is introduced, followed by a progressive/step-by-step optimization-based introduction to three types of trees (BST, B-Tree, LLRB).</p>
<p>The notes are divided into two parts, and this article only covers ADT and BST.</p>
<h2 id="abstract-data-types-adt">Abstract Data Types (ADT)<a hidden class="anchor" aria-hidden="true" href="#abstract-data-types-adt">#</a></h2>
<ul>
<li>An abstract data type is defined by its <strong>operations</strong>, not implementations.</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">Hierarchy</th>
<th style="text-align:center">Examples</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ADT</td>
<td style="text-align:center">Deque; DisjointSets</td>
</tr>
<tr>
<td style="text-align:center">Implementations of ADT</td>
<td style="text-align:center">ArrayDeque, LinkedListDeque;<br />QuickFindDS, WeightedQuickUnionDS</td>
</tr>
<tr>
<td style="text-align:center">Operations of ADT</td>
<td style="text-align:center"><code>size()</code>, <code>get()</code>, <code>addFirst(Item x)</code>, etc.</td>
</tr>
</tbody>
</table>
<ul>
<li>Among the most important interfaces in the java.util library are those that extend the <strong>Collection interface</strong>. The relationship is shown in the figure.
<ul>
<li>List</li>
<li>Set</li>
<li>Map</li>
</ul>
</li>
</ul>
<img src="./image-20230327205326564.png" alt="image-20230327205326564" style="zoom:50%;" />
<ul>
<li>The focus this time is on two tree-related data types, TreeSet and TreeMap.</li>
</ul>
<h2 id="binary-search-tree">Binary Search Tree<a hidden class="anchor" aria-hidden="true" href="#binary-search-tree">#</a></h2>
<h3 id="origins-of-bst">Origins of BST<a hidden class="anchor" aria-hidden="true" href="#origins-of-bst">#</a></h3>
<p>Question: How can we improve a linked list to perform searches more efficiently?</p>
<p>The answer is: 1) Set the entry point in the middle instead of one end. 2) Traverse from the middle to both ends. 3) Traverse in a skipping manner (as shown in the figure).</p>
<img src="./image-20230327210424890.png" alt="image-20230327210424890" style="zoom:50%;" />
<h3 id="definition-and-properties-of-bst">Definition and Properties of BST<a hidden class="anchor" aria-hidden="true" href="#definition-and-properties-of-bst">#</a></h3>
<ul>
<li>A binary search tree is a <strong>rooted</strong> <strong>binary</strong> <strong>tree</strong> with the <strong>BST property</strong>.
<ul>
<li>Tree properties:
<ul>
<li>A set of nodes</li>
<li>One path between any two nodes</li>
</ul>
</li>
<li>Rooted tree properties:
<ul>
<li>Each node, except the root, has only one parent node.</li>
<li>The root is typically drawn at the top.</li>
<li>For binary trees, each node can have 0/1/2 child nodes.</li>
</ul>
</li>
<li>BST properties:
<ul>
<li>Ordering: Every key in the <strong>left</strong> subtree is <strong>less</strong> than X&rsquo;s key. Every key in the <strong>right</strong> subtree is <strong>greater</strong> than X&rsquo;s key.</li>
<li>No duplicate keys are allowed.</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="./image-20230327211546048.png" alt="image-20230327211546048" style="zoom:50%;" />
<p>(Encountering a BST)</p>
<h3 id="bst-operations">BST Operations<a hidden class="anchor" aria-hidden="true" href="#bst-operations">#</a></h3>
<p>Three operations of BST are introduced.</p>
<h4 id="search--find">Search / Find<a hidden class="anchor" aria-hidden="true" href="#search--find">#</a></h4>
<h5 id="code-implementation">Code Implementation<a hidden class="anchor" aria-hidden="true" href="#code-implementation">#</a></h5>
<p>(It&rsquo;s easier to understand through the code.) Compare <code>searchKey</code> with <code>T.key</code> &ndash;&gt; Found! / <code>searchKey</code> is smaller, search <code>T.left</code> / <code>searchKey</code> is larger, search <code>T.right</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="c1">// reference: Algorithms, p.399
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cm">/** Return value associated with key in the subtree rooted at x;
</span></span></span><span class="line"><span class="cl"><span class="cm"> *  return null if key not present in subtree rooted at x.
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="n">Value</span> <span class="nf">get</span><span class="o">(</span><span class="n">Key</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">get</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">key</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">private</span> <span class="n">Value</span> <span class="nf">get</span><span class="o">(</span><span class="n">Node</span> <span class="n">x</span><span class="o">,</span> <span class="n">Key</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// helper
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">cmp</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">key</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">(</span><span class="n">cmp</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">get</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">key</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">cmp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">get</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">key</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h5 id="runtime-analysis">Runtime Analysis<a hidden class="anchor" aria-hidden="true" href="#runtime-analysis">#</a></h5>
<ul>
<li>Worst-case runtime: $\Theta(\log{N})$ for a dense binary tree.</li>
<li>Tree height: ~$\log_2{(N)}$
<ul>
<li>Consider the fact that each additional level requires twice the number of nodes.</li>
</ul>
</li>
</ul>
<h4 id="insert">Insert<a hidden class="anchor" aria-hidden="true" href="#insert">#</a></h4>
<h5 id="code-implementation-1">Code Implementation<a hidden class="anchor" aria-hidden="true" href="#code-implementation-1">#</a></h5>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="cm">/** Search for key. Update value if found; grow table if new. */</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">put</span><span class="o">(</span><span class="n">Key</span> <span class="n">key</span><span class="o">,</span> <span class="n">Value</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">root</span> <span class="o">=</span> <span class="n">put</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="cm">/** Change key&#39;s value to val if key in subtree rooted at x.
</span></span></span><span class="line"><span class="cl"><span class="cm"> *  Otherwise, add a new node to the subtree associating key with val. */</span>
</span></span><span class="line"><span class="cl"><span class="kd">private</span> <span class="n">Node</span> <span class="nf">put</span><span class="o">(</span><span class="n">Node</span> <span class="n">x</span><span class="o">,</span> <span class="n">Key</span> <span class="n">key</span><span class="o">,</span> <span class="n">Value</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="k">new</span> <span class="n">Node</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">val</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">cmp</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">key</span><span class="o">);</span> <span class="c1">// compare searchKey to curKey
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="o">(</span><span class="n">cmp</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">x</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">put</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">cmp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">x</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">put</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">x</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">val</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">x</span><span class="o">.</span><span class="na">N</span> <span class="o">=</span> <span class="n">size</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">+</span> <span class="n">size</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h5 id="runtime-analysis-for-insertion">Runtime Analysis for Insertion<a hidden class="anchor" aria-hidden="true" href="#runtime-analysis-for-insertion">#</a></h5>
<p>It should be the same as the search operation.</p>
<h4 id="delete">Delete<a hidden class="anchor" aria-hidden="true" href="#delete">#</a></h4>
<p>There are three cases for deletion:</p>
<ul>
<li>The key to be deleted <strong>has no</strong> child nodes (&ndash;&gt; see &ldquo;glut,&rdquo; simply disconnect).</li>
<li>The key to be deleted <strong>has one</strong> child node (&ndash;&gt; see &ldquo;flat,&rdquo; update the parent node&rsquo;s pointer to the child node).</li>
<li>The key to be deleted <strong>has two</strong> child nodes (as shown in the figure, find the predecessor or successor to replace its position).</li>
</ul>
<h5 id="code-implementation-p411">Code Implementation (p.411)<a hidden class="anchor" aria-hidden="true" href="#code-implementation-p411">#</a></h5>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">private</span> <span class="n">Node</span> <span class="nf">min</span><span class="o">(</span><span class="n">Node</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>              <span class="c1">// Find the smallest node and its child nodes under x
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">min</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">deleteMin</span><span class="o">()</span> <span class="o">{</span>               <span class="c1">// Return the root after deleting the smallest node
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">root</span> <span class="o">=</span> <span class="n">deleteMin</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">private</span> <span class="n">Node</span> <span class="nf">deleteMin</span><span class="o">(</span><span class="n">Node</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>         <span class="c1">// DeleteMin helper
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">x</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">deleteMin</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">x</span><span class="o">.</span><span class="na">N</span> <span class="o">=</span> <span class="n">size</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">+</span> <span class="n">size</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">delete</span><span class="o">(</span><span class="n">Key</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">root</span> <span class="o">=</span> <span class="n">delete</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">key</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">private</span> <span class="n">Node</span> <span class="nf">delete</span><span class="o">(</span><span class="n">Node</span> <span class="n">x</span><span class="o">,</span> <span class="n">Key</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">cmp</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">key</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">(</span><span class="n">cmp</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">x</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">delete</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">key</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">cmp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">x</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">delete</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">key</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>                                <span class="c1">// Assume the node P to be deleted has been found
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">right</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>  <span class="c1">// Check if P has sub-nodes, A) if it has 0/1 sub-nodes, return it
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">Node</span> <span class="n">t</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>                         <span class="c1">// B) if it has 2 nodes, the tree needs to be adjusted
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">x</span> <span class="o">=</span> <span class="n">min</span><span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>                   <span class="c1">// 1. Find the new substitute for the deleted node P
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">x</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">deleteMin</span><span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>       <span class="c1">// 2. Connect the updated right nodes to the new P
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">x</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>                    <span class="c1">// 3. Connect the original left sub-nodes to the new P
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// Note the order matters here!
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">x</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">.</span><span class="na">N</span> <span class="o">=</span> <span class="n">size</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">+</span> <span class="n">size</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h5 id="runtime-analysis-1">Runtime Analysis<a hidden class="anchor" aria-hidden="true" href="#runtime-analysis-1">#</a></h5>
<p>It should be of the same order as the previous operations since it only involves additional modification steps.</p>
<h3 id="bstset-vs-bstmap">BSTSet v.s. BSTMap<a hidden class="anchor" aria-hidden="true" href="#bstset-vs-bstmap">#</a></h3>
<p>This part introduces Lab9 BSTmap.</p>
<p>BSTSet and BSTMap have the same structure (a tree), but the difference is that each node is represented using a map (as shown in the figure).</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://flora025.github.io/tags/data-structure/">data structure</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="http://flora025.github.io/posts/2023/b-tree-llrb/">
    <span class="title">« Prev</span>
    <br>
    <span>61B Notes - B-Trees &amp; LLRB</span>
  </a>
  <a class="next" href="http://flora025.github.io/posts/2023/asymptotics2-notes/">
    <span class="title">Next »</span>
    <br>
    <span>61B Notes - Asymptotics II</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="http://flora025.github.io/">FloraZ</a></span><span style="display: inline-block; margin-left: 1em;">
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/reorx/hugo-PaperMod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
  (function() {
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    const disableSmoothScroll = '' == '1';
    const enableInstantClick = '' == '1';
    
    if (window.matchMedia('(prefers-reduced-motion: reduce)').matches || disableSmoothScroll || enableInstantClick) {
      return;
    }
    
    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                behavior: "smooth"
            });
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });
  })();
</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = 'copy';

        function copyingDone() {
            copybutton.innerText = 'copied!';
            setTimeout(() => {
                copybutton.innerText = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
<script>
window.addEventListener('DOMContentLoaded', function (event) {
  const headings = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id]');
  const activeClass = 'active';

  
  let activeHeading = headings[0];
  getLinkByHeading(activeHeading).classList.add(activeClass);

  const onScroll = () => {
    const passedHeadings = [];
    for (const h of headings) {
      
      if (getOffsetTop(h) < 5) {
        passedHeadings.push(h)
      } else {
        break;
      }
    }
    if (passedHeadings.length > 0) {
      newActiveHeading = passedHeadings[passedHeadings.length - 1];
    } else {
      newActiveHeading = headings[0];
    }
    if (activeHeading != newActiveHeading) {
      getLinkByHeading(activeHeading).classList.remove(activeClass);
      activeHeading = newActiveHeading;
      getLinkByHeading(activeHeading).classList.add(activeClass);
    }
  }

  let timer = null;
  window.addEventListener('scroll', () => {
    if (timer !== null) {
      clearTimeout(timer)
    }
    timer = setTimeout(onScroll, 50)
  }, false);

  function getLinkByHeading(heading) {
    const id = encodeURI(heading.getAttribute('id')).toLowerCase();
    return document.querySelector(`.toc ul li a[href="#${id}"]`);
  }

  function getOffsetTop(heading) {
    if (!heading.getClientRects().length) {
      return 0;
    }
    let rect = heading.getBoundingClientRect();
    return rect.top
  }
}, false);
</script></body>

</html>
