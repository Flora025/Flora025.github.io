<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>61B Notes - ADT and BST | FloraZ</title>
<meta name="keywords" content="数据结构">
<meta name="description" content="ヽ(´o｀；">
<meta name="author" content="Flora">
<link rel="canonical" href="http://Flora025.github.io/zh/posts/2023/bst/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.31d4ca0b0f0c25b30a5eeb159f350b1d5571601bc987f2d9189fa51d953169d0.css" integrity="sha256-MdTKCw8MJbMKXusVnzULHVVxYBvJh/LZGJ&#43;lHZUxadA=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f83806d9904cccf883edf075a5ce1d71136879702650d07aca8c76361a3e467b.js" integrity="sha256-&#43;DgG2ZBMzPiD7fB1pc4dcRNoeXAmUNB6yox2Nho&#43;Rns="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="http://Flora025.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://Flora025.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://Flora025.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://Flora025.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="http://Flora025.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="http://Flora025.github.io/zh/posts/2023/bst/">
<link rel="alternate" hreflang="en" href="http://Flora025.github.io/posts/2023/bst/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" integrity="sha384-GvrOXuhMATgEsSwCs4smul74iXGOixntILdUW9XmUC6+HX0sLNAK3q71HotJqlAn" crossorigin="anonymous">


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js" integrity="sha384-cpW21h6RZv/phavutF+AuVYrr+dA8xD9zs6FwLpaCct6O9ctzYFfFr4dgmgccOTx" crossorigin="anonymous"></script>


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>

    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "$$", right: "$$", display: true},
                    {left: "$", right: "$", display: false}
                ]
            });
        });
    </script><meta property="og:title" content="61B Notes - ADT and BST" />
<meta property="og:description" content="ヽ(´o｀；" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://Flora025.github.io/zh/posts/2023/bst/" /><meta property="og:image" content="http://Flora025.github.io/papermod-cover.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-27T22:36:43+08:00" />
<meta property="article:modified_time" content="2023-03-27T22:36:43+08:00" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="http://Flora025.github.io/papermod-cover.png"/>

<meta name="twitter:title" content="61B Notes - ADT and BST"/>
<meta name="twitter:description" content="ヽ(´o｀；"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://Flora025.github.io/zh/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "61B Notes - ADT and BST",
      "item": "http://Flora025.github.io/zh/posts/2023/bst/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "61B Notes - ADT and BST",
  "name": "61B Notes - ADT and BST",
  "description": "ヽ(´o｀；",
  "keywords": [
    "数据结构"
  ],
  "articleBody": "Reference是19sp的lec slides。\nTrees 首先引入abstract data type的概念，然后递进/逐步优化式地介绍三种树（BST, B-Tree, LLRB）。\n笔记会分成两部分，这一篇只整理ADT和BST。\nAbstract Data Types（ADT） An abstract data type is defined by its operations, not implementations. 层级 例子 ADT Deque; DisjointSets Implementations of ADT ArrayDeque, LinkedListDeque;\nQuickFindDS, WeightedQuickUnionDS Operations of ADT size(), get(), addFirst(Item x), etc. Among the most important interfaces in the java.util library are those that extend the Collection interface. 关系如图。 List Set Map 这次关注的是两个tree相关的，TreeSet和TreeMap。 Binary Search Tree BST缘起 问：怎么改进linkedlist，才能更加快速地完成搜索？\n答案是：1）将entry point设置在中间而不是一端 2）从中间往两端 3）跳跃地遍历（如图）\nBST定义与性质 A binary search tree is a rooted binary tree with the BST property. Tree properties: A set of nodes, One path between any two nodes Rooted trees prop: 除root外每个节点都只有一个父节点 root 一般画在最顶上 (for binary tree) 每个节点下只能有0/1/2个子节点 BST properties: Ordering: Every key in the left subtree is less than X’s key. Every key in the right subtree is greater than X’s key No duplicate keys allowed （路过一颗BST）\nBST Operations 介绍BST的三个operation。\nSearch / Find 代码实现 （看代码更方便）对比searchKey和T.key–\u003e 找到了！/ searchKey较小，search T.left / searchKey较大，search T.right\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // reference: Algorithms, p.399 /** Return value associated with key in the subtree rooted at x; * return null if key not present in subtree rooted at x. */ public Value get(Key key) { return get(root, key); } private Value get(Node x, Key key) { // helper if (x == null) return null; int cmp = key.compareTo(x.key); if (cmp \u003c 0) { return get(x.left, key); } else if (cmp \u003e 0) { return get(x.right, key); } else { return x.val; } } Runtime Analysis Worst case（茂密的二叉树.jpg）runtime：$\\Theta(log{N})$ Tree Height：~$log_2{(N)}$ 这样考虑：每增加一层需要x2倍的节点 Insert 代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /** Search for key. Update value if found; grow table if new. */ public void put(Key key, Value val) { root = put(root, key, val); } /** Change key’s value to val if key in subtree rooted at x. * Otherwise, add new node to subtree associating key with val. */ private Node put(Node x, Key key, Value val) { if (x == null) return new Node(key, val, 1); int cmp = key.compareTo(x.key); // compare searchKey to curKey if (cmp \u003c 0) { x.left = put(x.left, key, val); } else if (cmp \u003e 0) { x.right = put(x.right, key, val); } else { x.val = val; } x.N = size(x.left) + size(x.right) + 1; return x; } Insert.2 Runtime Analysis 应该和find一样。\nDelete 删除一共有三种情况：\n被删除的key没有子节点（–\u003esee “glut”, 直接断开连接）\n被删除的key有1个子节点（–\u003e see “flat”，把父节点的指针指向子节点）\n被删除的key有2个子节点（如图，找到predecessor或successor代替它的位置）\n代码实现 p.411 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 private Node min(Node x) {\t// 找到x下最小的节点\u0026其子节点 if (x.left == null) return x; return min(x.left); } public void deleteMin() {\t// 返回删除最小节点后的root root = deleteMin(root); } private Node deleteMin(Node x) {\t// deleteMinHelper if (x.left == null) return x.right; x.left = deleteMin(x.left); x.N = size(x.left) + size(x.right) + 1; return x; } public void delete(Key key) { root = delete(root, key); } private Node delete(Node x, Key key) { if (x == null) return null; int cmp = key.compareTo(x.key); if (cmp \u003c 0) { x.left = delete(x.left, key); } else if (cmp \u003e 0) { x.right = delete(x.right, key); } else {\t// 假设已经找到了Node P if (x.right == null) return x.left; // 确认P有无sub-nodes，A)有0/1subnodes则返回它 if (x.left == null) return x.right; Node t = x;\t// B) 有2个nodes就需要调整一下树 x = min(t.right); // 1. find the new substitute for the deleted node P x.right = deleteMin(t.right); // 2. connect the updated right nodes to the new P x.left = t.left;\t// 3. connect the original left sub-nodes to the new P // 注意这里的顺序matters！ } x.N = size(x.left) + size(x.right) + 1; return x; } Runtime 应该和前面是一个数量级，因为只是额外多了一些修改步骤。\nBSTSet v.s. BSTMap 这部分是Lab9 BSTmap的引入。\nBSTset和BSTmap结构相同（tree），区别是把每个node改成了用map来表示（如图）。\n",
  "wordCount" : "642",
  "inLanguage": "zh",
  "datePublished": "2023-03-27T22:36:43+08:00",
  "dateModified": "2023-03-27T22:36:43+08:00",
  "author":{
    "@type": "Person",
    "name": "Flora"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://Flora025.github.io/zh/posts/2023/bst/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "FloraZ",
    "logo": {
      "@type": "ImageObject",
      "url": "http://Flora025.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://Flora025.github.io/zh/" accesskey="h" title="FloraZ (Alt + H)">FloraZ</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                    <li>
                        <a href="http://Flora025.github.io/" title="English"
                            aria-label="English">English</a>
                    </li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://Flora025.github.io/zh/archives" title="归档">
                    <span>归档</span>
                </a>
            </li>
            <li>
                <a href="http://Flora025.github.io/zh/categories/" title="分类">
                    <span>分类</span>
                </a>
            </li>
            <li>
                <a href="http://Flora025.github.io/zh/tags/" title="标签">
                    <span>标签</span>
                </a>
            </li>
            <li>
                <a href="http://Flora025.github.io/zh/search/" title="搜索">
                    <span>搜索</span>
                </a>
            </li>
            <li>
                <a href="http://Flora025.github.io/zh/about/" title="关于">
                    <span>关于</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main post">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://Flora025.github.io/zh/">主页</a>&nbsp;»&nbsp;<a href="http://Flora025.github.io/zh/posts/">Posts</a></div>
    <h1 class="post-title">
      61B Notes - ADT and BST
    </h1>
    <div class="post-meta"><span title='2023-03-27 22:36:43 +0800 CST'>三月 27, 2023</span>&nbsp;·&nbsp;4 分钟&nbsp;·&nbsp;Flora&nbsp;|&nbsp;语言:
<ul class="i18n_list">
    <li>
        <a href="http://Flora025.github.io/posts/2023/bst/">English</a>
    </li>
</ul>

</div>
  </header> <div class="toc side">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">目录</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#trees" aria-label="Trees">Trees</a><ul>
                        
                <li>
                    <a href="#abstract-data-typesadt" aria-label="Abstract Data Types（ADT）">Abstract Data Types（ADT）</a></li>
                <li>
                    <a href="#binary-search-tree" aria-label="Binary Search Tree">Binary Search Tree</a><ul>
                        
                <li>
                    <a href="#bst%e7%bc%98%e8%b5%b7" aria-label="BST缘起">BST缘起</a></li>
                <li>
                    <a href="#bst%e5%ae%9a%e4%b9%89%e4%b8%8e%e6%80%a7%e8%b4%a8" aria-label="BST定义与性质">BST定义与性质</a></li>
                <li>
                    <a href="#bst-operations" aria-label="BST Operations">BST Operations</a><ul>
                        
                <li>
                    <a href="#search--find" aria-label="Search / Find">Search / Find</a><ul>
                        
                <li>
                    <a href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0" aria-label="代码实现">代码实现</a></li>
                <li>
                    <a href="#runtime-analysis" aria-label="Runtime Analysis">Runtime Analysis</a></li></ul>
                </li>
                <li>
                    <a href="#insert" aria-label="Insert">Insert</a><ul>
                        
                <li>
                    <a href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-1" aria-label="代码实现">代码实现</a></li>
                <li>
                    <a href="#insert2-runtime-analysis" aria-label="Insert.2 Runtime Analysis">Insert.2 Runtime Analysis</a></li></ul>
                </li>
                <li>
                    <a href="#delete" aria-label="Delete">Delete</a><ul>
                        
                <li>
                    <a href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-p411" aria-label="代码实现 p.411">代码实现 p.411</a></li>
                <li>
                    <a href="#runtime" aria-label="Runtime">Runtime</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#bstset-vs-bstmap" aria-label="BSTSet v.s. BSTMap">BSTSet v.s. BSTMap</a>
                </li>
            </ul>
            </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>Reference是19sp的lec slides。</p>
<h1 id="trees">Trees<a hidden class="anchor" aria-hidden="true" href="#trees">#</a></h1>
<p>首先引入abstract data type的概念，然后递进/逐步优化式地介绍三种树（BST, B-Tree, LLRB）。</p>
<p>笔记会分成两部分，这一篇只整理ADT和BST。</p>
<h2 id="abstract-data-typesadt">Abstract Data Types（ADT）<a hidden class="anchor" aria-hidden="true" href="#abstract-data-typesadt">#</a></h2>
<ul>
<li>An abstract data type is defined by its <strong>operations</strong>, not implementations.</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">层级</th>
<th style="text-align:center">例子</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ADT</td>
<td style="text-align:center">Deque; DisjointSets</td>
</tr>
<tr>
<td style="text-align:center">Implementations of ADT</td>
<td style="text-align:center">ArrayDeque, LinkedListDeque;<br /> QuickFindDS, WeightedQuickUnionDS</td>
</tr>
<tr>
<td style="text-align:center">Operations of ADT</td>
<td style="text-align:center"><code>size()</code>, <code>get()</code>, <code>addFirst(Item x)</code>, etc.</td>
</tr>
</tbody>
</table>
<ul>
<li>Among the most important interfaces in the java.util library are those that extend the <strong>Collection interface</strong>. 关系如图。
<ul>
<li>List</li>
<li>Set</li>
<li>Map</li>
</ul>
</li>
</ul>
<img src="./BST.assets/image-20230327205326564.png#center" alt="image-20230327205326564" style="zoom:50%;" />
<ul>
<li>这次关注的是两个tree相关的，TreeSet和TreeMap。</li>
</ul>
<h2 id="binary-search-tree">Binary Search Tree<a hidden class="anchor" aria-hidden="true" href="#binary-search-tree">#</a></h2>
<h3 id="bst缘起">BST缘起<a hidden class="anchor" aria-hidden="true" href="#bst缘起">#</a></h3>
<p>问：怎么改进linkedlist，才能更加快速地完成搜索？</p>
<p>答案是：1）将entry point设置在中间而不是一端 2）从中间往两端 3）跳跃地遍历（如图）</p>
<img src="./BST.assets/image-20230327210424890.png#center" alt="image-20230327210424890" style="zoom:50%;" />
<h3 id="bst定义与性质">BST定义与性质<a hidden class="anchor" aria-hidden="true" href="#bst定义与性质">#</a></h3>
<ul>
<li>A binary search tree is a <strong>rooted</strong> <strong>binary</strong> <strong>tree</strong> with the <strong>BST property</strong>.
<ul>
<li>Tree properties:
<ul>
<li>A set of nodes,</li>
<li>One path between any two nodes</li>
</ul>
</li>
<li>Rooted trees prop:
<ul>
<li>除root外每个节点都只有一个父节点</li>
<li>root 一般画在最顶上</li>
<li>(for binary tree) 每个节点下只能有0/1/2个子节点</li>
</ul>
</li>
<li>BST properties:
<ul>
<li>Ordering: Every key in the <strong>left</strong> subtree is <strong>less</strong> than X’s key. Every key in the <strong>right</strong> subtree is <strong>greater</strong> than X’s key</li>
<li>No duplicate keys allowed</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="./BST.assets/image-20230327211546048.png#center" alt="image-20230327211546048" style="zoom:50%;" />
<p>（路过一颗BST）</p>
<h3 id="bst-operations">BST Operations<a hidden class="anchor" aria-hidden="true" href="#bst-operations">#</a></h3>
<p>介绍BST的三个operation。</p>
<h4 id="search--find">Search / Find<a hidden class="anchor" aria-hidden="true" href="#search--find">#</a></h4>
<h5 id="代码实现">代码实现<a hidden class="anchor" aria-hidden="true" href="#代码实现">#</a></h5>
<p>（看代码更方便）对比<code>searchKey</code>和<code>T.key</code>&ndash;&gt; 找到了！/ <code>searchKey</code>较小，search <code>T.left</code> /  <code>searchKey</code>较大，search <code>T.right</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="c1">// reference: Algorithms, p.399
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cm">/** Return value associated with key in the subtree rooted at x;
</span></span></span><span class="line"><span class="cl"><span class="cm"> *  return null if key not present in subtree rooted at x.
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="n">Value</span> <span class="nf">get</span><span class="o">(</span><span class="n">Key</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">get</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">key</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">private</span> <span class="n">Value</span> <span class="nf">get</span><span class="o">(</span><span class="n">Node</span> <span class="n">x</span><span class="o">,</span> <span class="n">Key</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// helper
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">cmp</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">key</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="o">(</span><span class="n">cmp</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">get</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">key</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">cmp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">get</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">key</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h5 id="runtime-analysis">Runtime Analysis<a hidden class="anchor" aria-hidden="true" href="#runtime-analysis">#</a></h5>
<ul>
<li>Worst case（茂密的二叉树.jpg）runtime：$\Theta(log{N})$</li>
<li>Tree Height：~$log_2{(N)}$
<ul>
<li>这样考虑：每增加一层需要x2倍的节点</li>
</ul>
</li>
</ul>
<h4 id="insert">Insert<a hidden class="anchor" aria-hidden="true" href="#insert">#</a></h4>
<h5 id="代码实现-1">代码实现<a hidden class="anchor" aria-hidden="true" href="#代码实现-1">#</a></h5>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="cm">/** Search for key. Update value if found; grow table if new. */</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">put</span><span class="o">(</span><span class="n">Key</span> <span class="n">key</span><span class="o">,</span> <span class="n">Value</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">root</span> <span class="o">=</span> <span class="n">put</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="cm">/** Change key’s value to val if key in subtree rooted at x.
</span></span></span><span class="line"><span class="cl"><span class="cm"> *  Otherwise, add new node to subtree associating key with val. */</span>
</span></span><span class="line"><span class="cl"><span class="kd">private</span> <span class="n">Node</span> <span class="nf">put</span><span class="o">(</span><span class="n">Node</span> <span class="n">x</span><span class="o">,</span> <span class="n">Key</span> <span class="n">key</span><span class="o">,</span> <span class="n">Value</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="k">new</span> <span class="n">Node</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">val</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">cmp</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">key</span><span class="o">);</span> <span class="c1">// compare searchKey to curKey
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="o">(</span><span class="n">cmp</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">x</span><span class="o">.</span><span class="na">left</span>  <span class="o">=</span> <span class="n">put</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">,</span>  <span class="n">key</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">cmp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">x</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">put</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">x</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">val</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">   	<span class="n">x</span><span class="o">.</span><span class="na">N</span> <span class="o">=</span> <span class="n">size</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">+</span> <span class="n">size</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h5 id="insert2-runtime-analysis">Insert.2 Runtime Analysis<a hidden class="anchor" aria-hidden="true" href="#insert2-runtime-analysis">#</a></h5>
<p>应该和find一样。</p>
<h4 id="delete">Delete<a hidden class="anchor" aria-hidden="true" href="#delete">#</a></h4>
<p>删除一共有三种情况：</p>
<ul>
<li>
<p>被删除的key<strong>没有</strong>子节点（&ndash;&gt;see &ldquo;glut&rdquo;, 直接断开连接）</p>
<img src="./BST.assets/image-20230327215529578.png#center" alt="image-20230327215529578" style="zoom:50%;" />
</li>
<li>
<p>被删除的key<strong>有1个</strong>子节点（&ndash;&gt; see &ldquo;flat&rdquo;，把父节点的指针指向子节点）</p>
<img src="./BST.assets/image-20230327215709610.png#center" alt="image-20230327215709610" style="zoom:50%;" />
</li>
<li>
<p>被删除的key<strong>有2个</strong>子节点（如图，找到predecessor或successor代替它的位置）</p>
<img src="./BST.assets/image-20230327220006129.png#center" alt="image-20230327220006129" style="zoom:50%;" />
</li>
</ul>
<h5 id="代码实现-p411">代码实现 p.411<a hidden class="anchor" aria-hidden="true" href="#代码实现-p411">#</a></h5>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">private</span> <span class="n">Node</span> <span class="nf">min</span><span class="o">(</span><span class="n">Node</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>				<span class="c1">// 找到x下最小的节点&amp;其子节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">min</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">deleteMin</span><span class="o">()</span> <span class="o">{</span>				<span class="c1">// 返回删除最小节点后的root
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">root</span> <span class="o">=</span> <span class="n">deleteMin</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">private</span> <span class="n">Node</span> <span class="nf">deleteMin</span><span class="o">(</span><span class="n">Node</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>		<span class="c1">// deleteMinHelper
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">x</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">deleteMin</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">x</span><span class="o">.</span><span class="na">N</span> <span class="o">=</span> <span class="n">size</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">+</span> <span class="n">size</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">delete</span><span class="o">(</span><span class="n">Key</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">root</span> <span class="o">=</span> <span class="n">delete</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">key</span><span class="o">);</span>  
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">private</span> <span class="n">Node</span> <span class="nf">delete</span><span class="o">(</span><span class="n">Node</span> <span class="n">x</span><span class="o">,</span> <span class="n">Key</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">cmp</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">key</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">(</span><span class="n">cmp</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">x</span><span class="o">.</span><span class="na">left</span>  <span class="o">=</span> <span class="n">delete</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">,</span>  <span class="n">key</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">cmp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">x</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">delete</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">key</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>								<span class="c1">// 假设已经找到了Node P
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>       <span class="k">if</span> <span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">right</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>  <span class="c1">// 确认P有无sub-nodes，A)有0/1subnodes则返回它
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>       <span class="k">if</span> <span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">       <span class="n">Node</span> <span class="n">t</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>				<span class="c1">// B) 有2个nodes就需要调整一下树
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>       <span class="n">x</span> <span class="o">=</span> <span class="n">min</span><span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>       	<span class="c1">// 1. find the new substitute for the deleted node P
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>       <span class="n">x</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">deleteMin</span><span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="na">right</span><span class="o">);</span> <span class="c1">// 2. connect the updated right nodes to the new P
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>       <span class="n">x</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>			<span class="c1">// 3. connect the original left sub-nodes to the new P
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>       <span class="c1">// 注意这里的顺序matters！
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">x</span><span class="o">.</span><span class="na">N</span> <span class="o">=</span> <span class="n">size</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">+</span> <span class="n">size</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h5 id="runtime">Runtime<a hidden class="anchor" aria-hidden="true" href="#runtime">#</a></h5>
<p>应该和前面是一个数量级，因为只是额外多了一些修改步骤。</p>
<h3 id="bstset-vs-bstmap">BSTSet v.s. BSTMap<a hidden class="anchor" aria-hidden="true" href="#bstset-vs-bstmap">#</a></h3>
<p>这部分是Lab9 BSTmap的引入。</p>
<p>BSTset和BSTmap结构相同（tree），区别是把每个node改成了用map来表示（如图）。</p>
<img src="./BST.assets/image-20230327215109239.png#center" alt="image-20230327215109239" style="zoom:50%;" />

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://Flora025.github.io/zh/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="http://Flora025.github.io/zh/posts/2023/b-tree-llrb/">
    <span class="title">« 上一页</span>
    <br>
    <span>61B Notes - B-Trees &amp; LLRB</span>
  </a>
  <a class="next" href="http://Flora025.github.io/zh/posts/2023/asymptotics2-notes/">
    <span class="title">下一页 »</span>
    <br>
    <span>61B Notes - Asymptotics II</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="http://Flora025.github.io/zh/">FloraZ</a></span><span style="display: inline-block; margin-left: 1em;">
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/reorx/hugo-PaperMod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
  (function() {
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    const disableSmoothScroll = '' == '1';
    const enableInstantClick = '' == '1';
    
    if (window.matchMedia('(prefers-reduced-motion: reduce)').matches || disableSmoothScroll || enableInstantClick) {
      return;
    }
    
    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                behavior: "smooth"
            });
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });
  })();
</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = '复制';

        function copyingDone() {
            copybutton.innerText = '已复制！';
            setTimeout(() => {
                copybutton.innerText = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
<script>
window.addEventListener('DOMContentLoaded', function (event) {
  const headings = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id]');
  const activeClass = 'active';

  
  let activeHeading = headings[0];
  getLinkByHeading(activeHeading).classList.add(activeClass);

  const onScroll = () => {
    const passedHeadings = [];
    for (const h of headings) {
      
      if (getOffsetTop(h) < 5) {
        passedHeadings.push(h)
      } else {
        break;
      }
    }
    if (passedHeadings.length > 0) {
      newActiveHeading = passedHeadings[passedHeadings.length - 1];
    } else {
      newActiveHeading = headings[0];
    }
    if (activeHeading != newActiveHeading) {
      getLinkByHeading(activeHeading).classList.remove(activeClass);
      activeHeading = newActiveHeading;
      getLinkByHeading(activeHeading).classList.add(activeClass);
    }
  }

  let timer = null;
  window.addEventListener('scroll', () => {
    if (timer !== null) {
      clearTimeout(timer)
    }
    timer = setTimeout(onScroll, 50)
  }, false);

  function getLinkByHeading(heading) {
    const id = encodeURI(heading.getAttribute('id')).toLowerCase();
    return document.querySelector(`.toc ul li a[href="#${id}"]`);
  }

  function getOffsetTop(heading) {
    if (!heading.getClientRects().length) {
      return 0;
    }
    let rect = heading.getBoundingClientRect();
    return rect.top
  }
}, false);
</script></body>

</html>
