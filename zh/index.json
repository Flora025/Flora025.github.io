[{"content":" 又名：Gitlet in Hindsight: Why I Suggest U Always Read the DON\u0026rsquo;Ts Part in Spec First\n花了几天补票了61b的知名项目Gitlet——60页重量级spec面面俱到（笑），项目内容自带科普性，覆盖从系统设计到集成测试的每种技术基础普及和训练，不愧是该课史上评价最高的pj。\n【指路】UCB CS61B-21SP-Gitlet\n项目概述 Gitlet是一个版本管理系统，仿照主流系统Git的功能并实现了其部分基本命令，包括init, add, commit, rm, checkout, branch, reset, rm-branch, merge等。\n作为一个课程个人项目，开局仅有几个必要的类.java和几行代码样例，要求根据需求自行设计并完成系统、对象方法、数据结构和少量算法的构造。\nGitlet版本控制原理 Git（let）的版本控制说白了就是「怎么保存某个版本」和「怎么切换到某个版本」的问题。可以从由上至下三个层面理解这两个问题：一是从最上面的用户层面；二是从对象层面；三是从文件读写层面。\n从设计上来说这三层之间应该存在abtraction barrier。也就是说用户使用命令时不需要知道也不能操作对象、指针这些，对象之间也不应该出现文件读写操作。\n用户层面 先是一些上层发生的事情，也就是用户能知道的部分。\ngit初始化干了什么？在当前工作目录（CWD）创建一个.git的隐藏目录目录和里面的一些文件。 怎么保存文件的版本？每次commit时，获取所提交的文件的当前快照（snapshot），并保存在.git中。 怎么切换到指定的版本？使用像是checkout, reset 这样切换版本的命令时，git会根据给定的分支名/commit id等，在.git中查找对应的快照，然后把CWD中指定的文件或是整个目录还原成这个快照的样子。 对象层面 然后再看对象层是如何实现这几个步骤的。gitlet在一定程度上简化了git的目录结构，各个对象少存了一些元数据，但本质不变，就用gitlet举例了。下图里是.gitlet目录的结构示意。\ngitlet的版本控制实现用到了两类的对象：Commit和Blob。 每个Blob对象对应一个文件快照。 每个Commit对象对应一次commit。 怎么利用这些对象记录文件的版本？ 每次把文件加入staging area暂存区（add [file name]）时，会创建一个Blob对象存储当前的文件内容，然后把（文件名: 对应的Blob实例）映射关系丢到暂存区里。 每次commit一些文件时，会创建一个Commit对象，从暂存区把可以提交的映射关系保存进Commit对象中。每个对象里除了索引对以外还会记录其父Commit、时间戳、commit message等。 例子：下图中每个蓝色方块代表一个Commit对象，每个Commit对象中存有一个Map，里面记录了当前commit的文件对应的文件快照。比如Commit 1和Commit 2的Hello.txt都指向Blob 0，这就是说在两次commit时文件内容（快照）没有变化。 怎么实现切换到指定的版本？——移动指针 要让HEAD指针切换到另一个分支branchB的branchHeadCommit，这在对象层就等于：HEAD指针本来指向branchA上的某个Commit对象，现在让它指向另一个branchHeadCommit这个Commit对象。类似updatePointerToCommit(HEAD, branchHeadCommit)。 文件读写层面 最后看更低一层，文件读写层。因为执行一部分命令时要把Blob对象和Commit对象以及暂存区的当前内容存储到本地，这就涉及到两个问题：\n如何对象存成数据（方便后续需要的时候从文件中取出调用）？\n利用Java的序列化（Serialization）。Java里的序列化读写操作：\n在gitlet里，所有对象都是可以序列化存进文件里的，包括Blob、Commit和StagingArea（如有）。在.git里，它们被存放在/.git/objects/目录中。\n而指针变动实际是通过文件读写实现的（不需要序列化）。每个指针都是一个文件，文件里存着它指向的对象的id。在修改指针指向时，实际修改的是文件里的id。在.git里，它们被存放在.git/refs/目录中。\n1 2 3 4 5 6 7 8 9 10 11 /* Serialize a Model object */ Model m = ....; // 可序列化前提：Model类需要implements Serializable File outFile = new File(saveFileName); // 新建File try { ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(outFile)); out.writeObject(m); // 将对象写入steam out.close(); } catch (IOException excp) { ... } 1 2 3 4 5 6 7 8 9 10 11 12 /* Deserialize a Model object */ Model m; File inFile = new File(saveFileName); try { ObjectInputStream inp = new ObjectInputStream(new FileInputStream(inFile)); m = (Model) inp.readObject(); // cast object into expected class inp.close(); } catch (IOException | ClassNotFoundException excp) { ... m = null; } 如何查找并获取对象/修改指针指向？\nGitlet和Git都使用SHA-1（Secure Hash Algorithm 1）加密数据，产生一个160位的哈希值作为当前对象的id（40个十六进制数）。每个对象在创建时会根据自身的内容产生id，比如相同的文件内容经过加密会产生相同的id；并且它们保存的文件名就是它们的id。这意味着通过id就可以在目录中找到对应序列化过的对象。更重要的是，这就允许根据内容寻找文件的地址（content-addressable)。 关于对象获取，以获取Commit对象为例，步骤是：获得commit id（对象在构造时应有id字段） -\u0026gt; 根据id获取文件路径（因为都存放在指定目录下，根据id寻址） -\u0026gt; 反序列化文件。同理，修改就是修改对象内容后，再序列化写入文件。 关于修改指针指向，在文件读写层实际需要完成的操作是：获取targetCommit的id -\u0026gt; 把id写入HEAD指针对应的文件中。 （提醒自己）需要注意的是这些操作都应该封装在对象里，在主逻辑里不该出现commitMap.put(readContentAsString(commitPath), readContentAsString(blobPath))这种东西。写完翻别人实现的时候，看到有人是这样在对象层混用文件读写操作的，达咩。\n小结 以上是三遍不同的废话。版本控制系统类比一下基本就是：\n初始化版本控制系统 == 在当前工作目录放一个小盒子 保存文件的版本 == 每次提交时，把提交的东西拷一份存档放盒子里 切换当前目录/目录中某个文件到某个版本 == 在盒子里找对应的存档，拿出来放在CWD 其余的对象、指针和编码等等方式，都是用来精简每次拷贝的东西、加快盒子里找东西的速度的tricks（至少我是这么理解）：\nBlob对象 == 一个文件的存档 Commit对象 == 一张记录哪个时候该找哪个文件版本的小抄 Commit tree == 小抄们的目录大纲 SHA-1编码 == 给每个文件按照他们的内容起名（在快速对比文件内容、寻址上都有用） 指针 == 写着现在盒子里是哪个版本的标签 暴力存档谁都会（试想：paper_final_final_final.docx)，要说的话，我觉得精髓在于sha-1。\n思考 边写代码边记录的，比较乱\n关于spec阅读顺序 gitlet的项目说明很长，一次读完再开始不现实。如果再写一次，我会先看视频+扫读所有commands说明和avoids事项，然后边写边看。 spec里的「注意不要xxx」部分要仔细看，之所以写上去是因为大家真的会这样做，比如默认Map都是HashMap然后写出Heisenbug，实际为了维护顺序应该用TreeMap。←callback开头 关于设计 一开始需要整体地阅读spec，明确每个对象的作用和它们之间的常用交互方法，设计好了再开始实现。\n正面案例：在写\u0026lt;branch\u0026gt;命令的时候准备大改目录，但因为前面abstraction设计得还不错，除了File目录加一句以外什么都不需要改。\n保护abstraction barrier。上层对象之间的交互一定要避免使用底层操作。\n反面案例：前期直接在主逻辑里完成hashing、序列化，中间为了封装重构改了好久\n起名很重要。经过血的教训总结以下几点：\n统一性\u0026ndash;就像数据表连接一样，既然对象之间需要通信，那它们一定有一些共通的名字。反面案例就像是我一开始干的，把sha-1 hash得到的id，在不同类里写成shaName、shaId、hashName\u0026hellip; 直观性\u0026ndash;变量名越具体越好，比如map可以写出keyToVal，不然想起来费劲 泛用性\u0026ndash;方法最好不要太具体，这样再别处调用的时候也能想起来。比如getHead getMaster就可以写成getCommit/getPointer。 其他 可以读下git的源码寻找better practice，虽然只看spec也基本够用。 数据 time and space 代码总行数大约1k；时间上大概花了4.5天，wakatime统计的用时是40小时左右，虽然里面十多个小时在debug（。）这方面我记得Josh课上有分享同学的数据，大部分人完成时间也差不多是30-40hrs。\n从统计上看gitlet体量不大，不过考虑到它要求独立完成且涉及到了设计、单元和集成测试、makefile、java file i/o、算法、编码、甚至git本身的训练，还是非常rewarding的。\nAutograder情况 通过了所有功能性测试。Fail的几个Extra-Credit，style (mainly naming，下次一定)和迟交我认为无伤大雅，就没有继续面向autograder编程。\n没有写EC的原因：1）到了后期很多指令都是组合前面的指令，边际效益低；2）gitlet中的remote指令和git相去甚远，不见得有助于学习git的底层逻辑；3）在de了一个Heisenbug以后心力憔悴。\n感想 Gitlet是一款我的世界名校震撼.jpg 就像开头吹的一样，我坚信大部分水平和我类似的人都能通过这个project收获很多，具体只要看一眼spec就知道了。\n技术上我太菜也没资格说什么，只能最后讲几句别的。Josh在不记得哪节课上分享过Gitlet的survey结果，印象深刻的是有一部分学生在这个pj上花了50+小时（就我个人经历，这远超出正常大一的一门课的一个课设的workload），但是最后给了负面评价的只有寥寥几人，Josh好像还单独拿出来表示抱歉了。从侧面反映了The Gitlet Grind的价值。\n61B至此完结，感恩开源！继续肝别的去咯\n附录 以下是从写的readme中转载的my gitlet设计方面的说明\nDesign Abstraction Principle An issue with version control systems:\nRequires cumbersome operations like hashing, serialization, map operations, directory concatenation, file I/O, etc.\nSolution:\nOn a higher level, involve only communications between objects (between Blob and Commit, there should only be Blob b = commit1.get(filename)) Eliminate the need to dive into low-level operations through encapsulation. i.e. Outside the class of that object, never try to hash things, or modify maps inside Commit/Blob objects. E.g. The StagingArea supports common map operations. Upon put (fileName, Commit), it completes: read commit into commit id -\u0026gt; put into its map -\u0026gt; serialize itself and write into the file for staging. Persistence The directory structure looks like this:\n1 2 3 4 5 6 7 8 9 10 CWD └──.gitlet └── --commits/ # all commits ├──blobs/ # file content ├──branchHeads/ # branch heads | └──--master # master branch | ├──..\t# other branches ├──HEAD\t# HEAD commit ├──add # staging area for addition └──rm # staging area for removal The Main class is the entry class of the project. It is responsible for calling different functions according to given commands.\nThe Repository class will set up all persistance. It will\nCreate and initialize files and directories in the .gitlet folder if the directory does not exist; Handle all updates of HEAD , master, branchHeads and the serialization of two StagingAreas add and rm. Execute the commands / function calls from Main. The Commit class handles the serialization of Commit objects. It also deals with conversion between commit ids and commit objects. Each Commit records mappings of held file names and their corresponding file content. Specifically, it fulfil the following purposes:\nConstructs Commit objects; Serializes and saves Commit objects to the .gitlet/commits directory; Given a commit id, retrieves the corresponding Commit object. The Blob class handles the serialization of Blob objects. A blob is a snapshot of a file\u0026rsquo;s content at the moment of addition. For instance, a file named \u0026ldquo;hello.txt\u0026rdquo; can refer to different Blobs in different Commits.\nIts functions are similar to Commit, namely object construction, serialization and retrieval.\nThe StagingArea class stores files for addition and removal. A StagingArea works like a Java Map, stores mappings of file plain names to their blob ids, and supports basic map operations (remove, get, put). add and rm are StagingAreas for staged addition and removal respectively.\n","permalink":"http://eimy.ink/zh/posts/2023/gitlet-fin/","summary":"♪(´ε｀ )","title":"CS61B Gitlet 完结记录"},{"content":"日本中部旅游Plog ｜ 高山 富山 白川乡 先后拜访了富山-雨晴海岸、白川乡、高山市内。这段行程围绕巡礼展开，拉着朋友巡礼了几个非常喜欢的作品的取景地1。这次来日本可以说就是为了巡礼，等了好多年才有机会，对我来说比毕业意义重大。\n富山 Toyama 01: 等了五年的「ただ君に晴れ」圣地巡礼（雨晴海岸）\n天气特别好，海风凉爽\n高山 Takayama 02: 最最喜欢的动画「氷菓」的巡礼\n出门时只是为了找飛騨牛吃，回过神来已经坐在了冰菓咖啡厅\n后面还找到了op很多镜头的取景地点\n03: 高山一家叫「丸明」的飛騨牛店，连吃了两次，好吃得做梦都想追着牛啃\n白川乡 Shirakawa-Go 04: 某书上吹成网红的白川乡，其本体竟是寒蝉里的雏见泽村\n这么接地府的地方被当天堂拍..（但确实是一个很平静的村子）\n最后一点话\n这是第一次和朋友单独出国旅行。曾经去过欧洲北美东亚的几个国家，但每次回忆的时候发现旅游的细节都忘得差不多了，只剩下一些很朦胧的印象，于是就会责怪自己怎么这么不认真对待机会、是不是在仓促的行程中忽略了很多值得注意的文化风情etc。\n这次在路上一直反思，这些经历除了作为谈资还给我带来了什么，最后我得出的结论是「旅行的意义是去审视异己感，然后在差异中认识自己」。\n我对异己感的定义是两重的：第一是文化的差异，在进入异域文化的「日常」的时候，很容易发现当地人和自己的行为/观念差异，而「我认识的/做的为什么和他们不一样」值得细想。为什么日本人这么礼貌？为什么我讲汉语英文没事，但说日语的时候会下意识道谢鞠躬？文化的性质到底是「基因」还是「氛围」？环境和教育哪个对人影响更大？这都是很有趣的问题。\n第二是个人之间的差异，因为是在较长的时间内和朋友一起完成衣食住行的所有任务，矛盾很容易暴露出来（不是冲突的意思，是广义的矛盾），借这个机会，还可以在比较中确定自己到底在人格/性格/思维谱系中的相对位置。我觉得确实如此，这次旅行中好几次遇到「你为什么会这么想/怎么是这个反应」的时刻。盆友诧异我旅游还带电脑天天熬夜肝任务，我羡慕盆友可以很放松地享受生活和旅行；分享了我最近感兴趣的okr人生管理方法x，盆友说完全不能接受，觉得非常压抑受限，大家就是会有不同的思维方式。\n总之，旅行是非常个人的事情，它不是田野调查，没必要从中考察出什么社会现象文化理论，所以很模糊的体验也没问题，只要多想想所见人事物和自己的异同就算有收获（还有多吃好吃的 好想念鸟贵族）。虽然看的是外部世界，但目光最终是落在自己身上的。\n以上看起来非常故弄玄虚，实际到处玩的时候没想这么多，大部分时间在吃饭走路睡觉，小部分时间做些坏事，比如和朋友互坑2、享受日本人没发现我不是日本人的时刻3。说明日语水平提高了，一定要炫耀一下。\n「氷菓」——初中看的一部12年的轻改动画和「ただ君に晴れ」——一个18年的歌曲mv\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n因为有人想去大阪的八阪神社，但是长途跋涉把我带到了京都的八阪神社呢\u0026hellip;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n比如成功伪装土著帮日本人指路，比如成功伪装日本人点单\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"http://eimy.ink/zh/posts/2023/plog-japan-ii/","summary":"高山 富山 白川乡","title":"日本中部旅游Plog 2"},{"content":"日本关西-中部旅行Plog 大阪 01: 用荒诞的结束方式否定荒诞的本科时光（指缺席自己毕业典礼）\n02: 幼年卡比兽在马里奥餐厅进食珍贵影像\n03: 自学七年日语，归来仍是英文点单\n注: 看日本麦门菜单体验堪比阅读日文版元素周期表\n04: hogwarts里乌漆麻黑像回到了房间一样，真好.jpg\n05: (咒回4D电影候场）但如果我的咒术和kita一样，阁下该如何应对呢？\n注：「あなたの呪術が世界を救う」＝你的咒术将拯救世界\n","permalink":"http://eimy.ink/zh/posts/2023/plog-japan-i/","summary":"讲五个不好笑的冷笑话","title":"日本关西旅游Plog 1"},{"content":"闪现！四年后 录取通知书 - 19年报名@老番茄的活动时拍的 毕业纪念纸 - 23年6/13的毕业典礼 零碎的感想 有很多遗憾：在一个巨大的错误中试错，试一个错一个\n明确了价值：四年后终于可以坚定地说出我追求的不是“自由而无用”（民间校训）\n四年后还是没能和专业和解，我的黑灰底色还是和它格格不入，但感谢它把我染成五彩斑斓的黑（？\n典礼上老师的赠言: I guess this is goodbye -- from Lost in Translation 岂止lost in translation，大多事情是lost in expression，语言里找不到明确的答案（所以润了）。\n最近期末叠加毕业，忙得没时间整理东西。明天又要考试，认真学了四年还是那么地不擅长，最后只能归结为没有天赋了哈哈（A-是我对自己本科学力的全部理解）\n","permalink":"http://eimy.ink/zh/posts/2023/graduation/","summary":"「がんばってもそれが公正に報われない社会があなたたちを待っています」","title":"Graduation"},{"content":"Hashing 这一课笔记的逻辑结构和课件略有区别，总体根据最初设定的两个优化目标分为两部分。\n第一部分找到一种数据结构（hash table），解决了search tree的generalization的问题；第二部分优化这个结构，解决了performance的问题。\nLimits of Search Tree sets requires the objects to be comparable performance not good enough (Θ(log N)) 因此之后的改进主要在这两方面：1）generalize to more types of objects；2）节约内存、降低复杂度。\nGeneralization to various objects 第一部分找到一种数据结构（hash table），解决了search tree的generalization的问题\nA Better Structure: Data Indexed Sets 这一部分从generalization入手，从Data Indexed Integer Set (Int -\u0026gt; index）引入，扩展到Data Indexed English Word Set（EN word -\u0026gt; Int -\u0026gt; index），最后一步步generalize到Data Indexed String Set（String -(based on ASCII)-\u0026gt; Int -\u0026gt; index）。\n首先想到的是Data Indexed Integer Set 缺点是它太浪费memory了，并且无法表示除了integer以外的其他对象 其次，为了能够表示其他种类的对象，通过进制转换将字母转换成integer的index。 在进制的选择上，为了防止index重复（collision），选择base \u0026gt;= N（item种类） 比如将27作为base转换26个字母 因此就有了Data Indexed English Word Set。 缺点是这个方法无法应对字符（“eGg!”） 为了进一步从英文单词generalize到字符，采用ASCII码/Unicode将String转化为index。 于是进化出了Data Indexed String Set 缺点是index过大，会造成overflow，超过java的限制（+2,147,483,647）。 而overflow会进一步导致index重复（collision） 为了“解决”这个generalization部分的遗留问题，将引入hash code的编码方式。\nHandling Collision: Hash Code and Hash Table Definition:\na hash code “projects a value from a set with many (or\neven an infinite number of) members to a value from a set with a fixed\nnumber of (fewer) members.”\n首先“解决”刚才的overflow导致collision的问题。 turns out collision无法避免，只能应对。\n应对方法是把hashcode相同的item放进一个bucket。可以用LinkedList、ArrayList、ArraySet等等。 bucket在示意图里是每一个index格子所指向的一筐item。 于是它又进化成了Separate Chaining Data Indexed Array 终于处理好了collision——这也意味着generalization部分的问题至此彻底解决。\nImproving Performance 第二部分优化hash table的结构，解决了performance的问题\n接下来就是开头的第二个问题performance（memory \u0026amp; complexity）。\n这个问题可以分解为两部分，一是几万个bucket太浪费memory，二是complexity可能会很高（比如所有的item都连成了一串）。\nSaving Memory 为了节约memory，改成只用N个bucket。\n方法是HashCode % NumBuckets把hashCode重新归档。比如，只用10个bucket，就把hashCode%10：\n以上完成的就是Hash Table。完整流程示意图如下：\nReducing Complexity 为了让每个bucket里的平均item数量保持恒定，需要动态改变bucket数量——resizing。\n具体来说，\n已知N为item总数，M为bucket总数 设定load factor = N / M （即最多平均每个bucket里有几个item） 下为示意图，如果load factor ≥ 1.5，将bucket数M翻倍：\nFinale: Hash Table Runtime Analysis Worst Case Runtime:\ncontains(x) add(x) Bushy BSTs Θ(log N) Θ(log N) DataIndexedArray Θ(1) Θ(1) Separate Chaining Hash Table With No Resizing Θ(N) Θ(N) \u0026hellip; With Resizing Θ(1)† Θ(1)*† *: Indicates “on average”. †: Assuming items are evenly spread. 这里尤其要注意，如果hashCode()不好（无法平均分配items），那么还是会像without resizing的HT一样有Θ(N)。\n有了resizing后，worst case operation数\n不再是遍历全部连成一串的N个item【$\\Theta(N)$】 而是遍历最多N/M个item【$\\Theta(N/M) = \\Theta(1)$】 由此performance的问题也解决了。\n(Op) How to Compute a hashCode Q: How to write a good hashCode() method?\nA: Use a small prime base, for it yields better randomness and cost less to compute\n下面是两个hashCode()方法的例子：\n1 2 3 4 5 6 7 8 9 10 // Hashing a collection @Override public int hashCode() { int hashCode = 1; for (Object o : this) { hashCode = hashCode * 31; // elevate the current hash code hashCode = hashCode + o.hashCode(); // add new item’s hash code } return hashCode; } 1 2 3 4 5 6 7 8 9 10 // Hashing a recursive structure (e.g. a tree) @Override public int hashCode() { if (this.value == null) { return 0; } return this.value.hashCode() + 31 * this.left.hashCode() + 31 * 31 * this.right.hashCode(); } ","permalink":"http://eimy.ink/zh/posts/2023/hashing/","summary":"\\hashbrown/\\hashbrown/","title":"61B Notes - Hashing"},{"content":"B-Tree, LLRB Hug一般会顺滑地衔接/引入知识点，但这些衔接部分写在笔记里多少有点啰嗦，所以这里会略写。\nBST的局限 先引入两个BST的属性：height和average depth height：determines the worst case runtime to find a node average depth：determines the average case runtime to find a node 然后看看BST的各种属性 Worst case $ \\Theta( N)$ height Best case $ \\Theta(log N)$ height Random trees have $ \\Theta(log N)$ average depth and height (bushy) 随机情况下表现还不错，问题是现实中会不断从右边insert数据，这会导致不平衡，比如 add(“01-Jan-2019, 10:31:00”) add(“01-Jan-2019, 18:51:00”) B-Trees / 2-3 trees / 2-3-4 trees 接上，为了防止不平衡，我们不断把新的key insert进原来的node中，然后进行node splitting。\n于是就出现了新的树B-trees。\nB-trees should be called juicy trees.\n定义 B-tree是一种自平衡树，总的分为以下几类： B-trees of order L=3 (like we used today) are also called a 2-3-4 tree or a 2-4 tree（如图） B-trees of order L=2 are also called a 2-3 tree （如图） B-trees of large L are used in practice for databases etc. 构成机制 （node-split）\n1/ Insert into a leaf until the number of keys exceeds L\n2/ In case of excessive keys, send the second (1 st) node up, and split the node\n几个例子：\n【非连锁反应】 【涉及到连锁反应】 【涉及到root split】 性质 （or Invariants）\n基于以上构成机制，可以得出B-tree的一些性质。B-trees are balanced in that:\nAll leaves must be the same distance from the source\n考虑：涉及到root-split，height+1，所有node都会下降一层； 如不涉及root-split，height不变 A non-leaf node with k items must have exactly k+1 children\nRuntime Analysis Height：Θ(log N) for both worst cast and best case best case是每个node都有L个items（满的） $\\Rightarrow$ Height grows with $\\Theta(log_{L+1}N)$ worst case是每个node只有1个item $\\Rightarrow$ 所以和BST一样Height grows with $\\Theta(log_2N)$ operation runtime: contains() and add() are both $O(log N)$ 【worst case】contains(): $C = （层数）log_{L+1}{N} \\space·\\space （node \\space per \\space layer）1 \\space·\\space （work \\space per \\space node）L$ 【worst case】add(): 多了一些split operation，但化简后是一样的 B-Tree的局限 猜猜为什么上面没有代码实现部分\nLeft Leaning Red-Black Trees 定义 A BST with left glue links that represents a 2-3 tree is often called a “Left Leaning Red Black Binary Search Tree” or LLRB\n可以理解为：LLRB是一种和某一个B-Tree对应的BST。具体备注：\nLLRBs are normal BSTs! There is a 1-1 correspondence between an LLRB and an equivalent 2-3 tree. The red is just a convenient fiction. Red links don’t “do” anything special 性质 和BST一样\n尤其需要注意的几个性质：\nAll leaves must be the same distance from the source（只数black links） No node has two red links 构成机制 原理上是基于2-3 tree，将node中较小的item下移，如 实际上，因为不可能先实现2-3 tree，再调整成LLRB。在代码中会利用red link, rotate, flip color直接实现LLRB：\nalways use a red link when inserting （类比在2-3中会先往node中添加item）\nwhen inserting items on the right, rotateLeft()\nwhen inserting on the left twice, rotateRight()\n(a new rule) allows representing temporary 4-nodes as BST nodes with two red links\nIn case of tmp 4-nodes, flipcolor().\nIf a rotation or flip operation cause an additional violation, fix it\n代码实现 以下是这些方法的代码实现，包括调整过的Node Class、put()、新增的rotate系列、flipColors()和isred()。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 // LLRB insertion (p.439) public class RedBlackBST\u0026lt;Key extends Comparable\u0026lt;Key\u0026gt;, Value\u0026gt; { private Node root; private class Node // BST node with color bit (see page 433) private boolean isRed(Node h) // See page 433. private Node rotateLeft(Node h) // See page 434. private Node rotateRight(Node h) // See page 434. private void flipColors(Node h) // See page 436. private int size() // See page 398. public void put(Key key, Value val) { // Search for key. Update value if found; grow table if new. root = put(root, key, val); root.color = BLACK; } private Node put(Node h, Key key, Value val) { if (h == null) { // Do standard insert, with red link to parent. return new Node(key, val, 1, RED); } int cmp = key.compareTo(h.key); if (cmp \u0026lt; 0) { h.left = put(h.left, key, val); } else if (cmp \u0026gt; 0) { h.right = put(h.right, key, val); } else { h.val = val; } if (isRed(h.right) \u0026amp;\u0026amp; !isRed(h.left)) { // 基于BST只需要修改这里三个clause h = rotateLeft(h); } if (isRed(h.left) \u0026amp;\u0026amp; isRed(h.left.left)) { h = rotateRight(h); } if (isRed(h.left) \u0026amp;\u0026amp; isRed(h.right)) { flipColors(h); h.N = size(h.left) + size(h.right) + 1; return h; } } // some omitted methods within RedBlackBST Class private boolean isRed(Node x) { if (x == null) return false; return x.color == RED; } private Node rotateLeft(Node h) { // rotateRight() is similar Node x = h.right; h.right = x.left; x.left = h; x.color = h.color; h.color = RED; x.N = h.N; h.N = 1 + size(h.left) + size(h.right); return x; } private void flipColors(Node h) { h.color = RED; h.left.color = BLACK; h.right.color = BLACK; } } // delete比较麻烦，详细见p.441. Runtime Analysis Height: $O(logN)$ contains(): $O(logN)$ insert(): $O(logN)$ $O(logN)$ to add the new node $O(logN)$ for rotation and color flip operations per insert （化简后忽略常数 所以还是 $O(logN)$） Summary of search trees 逻辑梳理 Cited from the slides [lec 18, 19sp]\nBinary search trees** are simple, but they are subject to imbalance.\n2-3 Trees (B Trees) are balanced, but painful to implement and relatively slow.\nLLRBs insertion is simple to implement (but delete is hard).\nWorks by maintaining mathematical bijection with a 2-3 trees. Java’s TreeMap is a red-black tree (not left leaning).\nMaintains correspondence with 2-3-4 tree (is not a 1-1 correspondence).\nAllows glue links on either side (see Red-Black Tree).\nMore complex implementation, but significantly (?) faster.\nComplexity/runtime对比 WC = worst case\nBST B-Trees LLRB Height $O(logN)$ $\\Theta(logN)$ $O(logN)$ WC：$O(N)$ WC：$O(log N)$ WC：$O(log N)$ contains() $O(logN)$ $O(log N)$ $O(logN)$ WC：$O(N)$ WC：$O(log N)$ WC：$O(log N)$ insert() $O(logN)$ $O(log N)$ $O(logN)$ WC：$O(N)$ WC：$O(log N)$ WC：$O(log N)$ 说明：B树和LLRB是self-balanced（不会出现BST变成LinkedList的极端情况），所以比较快。\n总的来说：\nB-trees的自平衡避免了BST的worst-cast complexity， 而LLRB不仅继承了B-trees的自平衡特性，还继承了BST易于实现的特点。 ","permalink":"http://eimy.ink/zh/posts/2023/b-tree-llrb/","summary":"B树と旋转と红黑色树","title":"61B Notes - B-Trees \u0026 LLRB"},{"content":"Reference是19sp的lec slides。\nTrees 首先引入abstract data type的概念，然后递进/逐步优化式地介绍三种树（BST, B-Tree, LLRB）。\n笔记会分成两部分，这一篇只整理ADT和BST。\nAbstract Data Types（ADT） An abstract data type is defined by its operations, not implementations. 层级 例子 ADT Deque; DisjointSets Implementations of ADT ArrayDeque, LinkedListDeque;\nQuickFindDS, WeightedQuickUnionDS Operations of ADT size(), get(), addFirst(Item x), etc. Among the most important interfaces in the java.util library are those that extend the Collection interface. 关系如图。 List Set Map 这次关注的是两个tree相关的，TreeSet和TreeMap。 Binary Search Tree BST缘起 问：怎么改进linkedlist，才能更加快速地完成搜索？\n答案是：1）将entry point设置在中间而不是一端 2）从中间往两端 3）跳跃地遍历（如图）\nBST定义与性质 A binary search tree is a rooted binary tree with the BST property. Tree properties: A set of nodes, One path between any two nodes Rooted trees prop: 除root外每个节点都只有一个父节点 root 一般画在最顶上 (for binary tree) 每个节点下只能有0/1/2个子节点 BST properties: Ordering: Every key in the left subtree is less than X’s key. Every key in the right subtree is greater than X’s key No duplicate keys allowed （路过一颗BST）\nBST Operations 介绍BST的三个operation。\nSearch / Find 代码实现 （看代码更方便）对比searchKey和T.key\u0026ndash;\u0026gt; 找到了！/ searchKey较小，search T.left / searchKey较大，search T.right\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // reference: Algorithms, p.399 /** Return value associated with key in the subtree rooted at x; * return null if key not present in subtree rooted at x. */ public Value get(Key key) { return get(root, key); } private Value get(Node x, Key key) { // helper if (x == null) return null; int cmp = key.compareTo(x.key); if (cmp \u0026lt; 0) { return get(x.left, key); } else if (cmp \u0026gt; 0) { return get(x.right, key); } else { return x.val; } } Runtime Analysis Worst case（茂密的二叉树.jpg）runtime：$\\Theta(log{N})$ Tree Height：~$log_2{(N)}$ 这样考虑：每增加一层需要x2倍的节点 Insert 代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /** Search for key. Update value if found; grow table if new. */ public void put(Key key, Value val) { root = put(root, key, val); } /** Change key’s value to val if key in subtree rooted at x. * Otherwise, add new node to subtree associating key with val. */ private Node put(Node x, Key key, Value val) { if (x == null) return new Node(key, val, 1); int cmp = key.compareTo(x.key); // compare searchKey to curKey if (cmp \u0026lt; 0) { x.left = put(x.left, key, val); } else if (cmp \u0026gt; 0) { x.right = put(x.right, key, val); } else { x.val = val; } x.N = size(x.left) + size(x.right) + 1; return x; } Insert.2 Runtime Analysis 应该和find一样。\nDelete 删除一共有三种情况：\n被删除的key没有子节点（\u0026ndash;\u0026gt;see \u0026ldquo;glut\u0026rdquo;, 直接断开连接）\n被删除的key有1个子节点（\u0026ndash;\u0026gt; see \u0026ldquo;flat\u0026rdquo;，把父节点的指针指向子节点）\n被删除的key有2个子节点（如图，找到predecessor或successor代替它的位置）\n代码实现 p.411 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 private Node min(Node x) {\t// 找到x下最小的节点\u0026amp;其子节点 if (x.left == null) return x; return min(x.left); } public void deleteMin() {\t// 返回删除最小节点后的root root = deleteMin(root); } private Node deleteMin(Node x) {\t// deleteMinHelper if (x.left == null) return x.right; x.left = deleteMin(x.left); x.N = size(x.left) + size(x.right) + 1; return x; } public void delete(Key key) { root = delete(root, key); } private Node delete(Node x, Key key) { if (x == null) return null; int cmp = key.compareTo(x.key); if (cmp \u0026lt; 0) { x.left = delete(x.left, key); } else if (cmp \u0026gt; 0) { x.right = delete(x.right, key); } else {\t// 假设已经找到了Node P if (x.right == null) return x.left; // 确认P有无sub-nodes，A)有0/1subnodes则返回它 if (x.left == null) return x.right; Node t = x;\t// B) 有2个nodes就需要调整一下树 x = min(t.right); // 1. find the new substitute for the deleted node P x.right = deleteMin(t.right); // 2. connect the updated right nodes to the new P x.left = t.left;\t// 3. connect the original left sub-nodes to the new P // 注意这里的顺序matters！ } x.N = size(x.left) + size(x.right) + 1; return x; } Runtime 应该和前面是一个数量级，因为只是额外多了一些修改步骤。\nBSTSet v.s. BSTMap 这部分是Lab9 BSTmap的引入。\nBSTset和BSTmap结构相同（tree），区别是把每个node改成了用map来表示（如图）。\n","permalink":"http://eimy.ink/zh/posts/2023/bst/","summary":"ヽ(´o｀；","title":"61B Notes - ADT and BST"},{"content":"注：本文原文为英语，由ChatGPT翻译成中文。\n计算$\\Theta (f(N))$的技巧 示例1：一个For循环 1 2 3 4 5 6 int N = A.length; for (int i = 0; i \u0026lt; N; i += 1) for (int j = i + 1; j \u0026lt; N; j += 1) if (A[i] == A[j]) return true; return false; 方法1：计算操作次数（精确计数） \u0026ldquo;==\u0026ldquo;操作的总成本/操作次数为： $$ C(N)=1+2+3+\\dots+(N-2)+(N-1) = \\frac{N(N-1)}{2} $$ 因此，运行时间为$\\Theta (N^2)$。\n方法2：几何可视化 （想象彩色方块-由于是一个三角形区域-运行时间为$\\Theta (N^2)$。）\n示例2：另一个For循环 1 2 3 4 5 6 7 8 public static void printParty(int N) { for (int i = 1; i \u0026lt;= N; i = i * 2) { for (int j = 0; j \u0026lt; i; j += 1) { System.out.println(\u0026#34;hello\u0026#34;); int ZUG = 1 + 1; } } } 方法1：通过可视化找到界限 绘制0.5N（下方虚线）和4N（上方虚线）的轨迹\nC(N)将位于这两条线之间\n因此，运行时间为$\\Theta (N)$。\n（个人认为这种方法不如数学方法直观。）\n方法2：通过数学方法找到界限 想象一下方框：\n基于简化的几何分析 因此，$C(N)$将为： $$ C(N)=1+2+4+\\dots+N= 2N-1 $$ 因此，运行时间为$\\Theta (N)$。\n示例3：树递归 1 2 3 4 5 public static int f3(int n) { if (n \u0026lt;= 1) return 1; return f3(n-1) + f3(n-1); } 方法1：直觉 每次将n增加1，工作量加倍\n\u0026hellip;这导致运行时间直观上为$2^N$。\n树递归 方法2：代数 $C(N)$的成本为： $$ C(N) = 1+2+4+\\dots+2^\\left(N-1\\right)=2^N-1 $$ 因此，运行时间为$\\Theta (2^N)$。\n方法3：递归关系（超出范围） 从以下开始： $$ C(N)=2C(N-1)+1 $$\n示例4：二分查找 二分查找 方法1：直觉 我们从N个选项开始，然后N/2，然后N/4 \u0026hellip; 直到只剩下1个。\n每次，我们将数组分成两半，因此最后我们必须执行总共$\\log_{2}(N)$次操作\u0026hellip;\n因此，总体运行时间为$\\Theta (\\log(N))$。\n方法2：精确计数 二分查找 因此，$C(N)=\\left\\lfloor \\log_{2}(N) \\right\\rfloor + 1$（根据观察）。\n运行时间为$\\Theta(\\log(N))$。\n示例5：归并排序 任意时间单位：相对的时间需求 例如，如果我们运行N=6的选择排序，运行时间的阶数为$N^2$，那么运行时间将为约36个AU。\n关于归并排序-一个简单的情况（将两个列表合并为一个） 归并排序 其运行时间为$\\Theta (N)$。\n归并排序-将归并排序应用于排序一个长列表 归并排序 关键思想是将原始数组分割成最小的片段，并应用归并排序（其运行时间为$\\Theta (N)$）。\n因此，归并排序的最坏情况运行时间为$\\Theta (N \\cdot \\log(N))$，其中\n最上层花费约N个AU。\n下一层花费约N/2 + N/2 = N个AU。\n再下一层：N/4 + N/4 + N/4 + N/4 = N个AU。\nSummary There is no magic. Just count. 一个比较规范的方法见disc07的andwelcome()： 【1】求Tree Height (number of layers)，如二叉树的话就是$logN$ 【2】求branching factor（分叉系数/ nodes per layer），如二叉树是$2^N$ 【3】求每个node的operations (work per node)，如二叉树是$N/2^i$ 最后乘起来：$\\sum_{i=0}^{logN}\\space·\\space2^i\\space·\\space(\\frac{N}{2^i}) = n\\log{N}$ ","permalink":"http://eimy.ink/zh/posts/2023/asymptotics2-notes/","summary":"copied from the textbook","title":"61B Notes - Asymptotics II"},{"content":"Asymptotics CS61b算法部分的第一个lecture（中英混记）。记录的是lec的主要脉络。\nGeneral Goal 这部分引出核心问题——“如何衡量算法效率”。\nEfficiency comes in two ways\n编程成本（programming cost）\u0026lt;\u0026ndash; 61b前半程的关注点 执行成本（execution cost）\u0026lt;\u0026ndash; 现在开始的关注点 time cost memory cost 引出问题：How to measure code efficiency？\n因此这一讲的目标是引入衡量算法效率的正式标准\nIntuitive Runtime Characterizations 这部分由浅入深展示了几个可以衡量程序效率的方法。\n比较执行时间 优点是直观，缺点是因为影响因素过多，不太可靠 计算所有运算步骤累计次数（用实数/抽象N表示） 优点是可以看出增长规模（how it scales），但是算起来麻烦 scrnshot Asymptotic Analysis 这部分首先介绍算法效率多大程度上受到增长规模（order of growth）的影响，然后引出能够简化渐进分析的方法。\nOrder of Growth的影响\n基本原则是，在分析效率时，只关注asymptotic behavior（即N趋向无穷大时的表现）\n基于这个原则，可以观察比较N无穷大时的函数形状\n暂时称这个函数形状为order of growth，比如它可以是line、cubic、quadratic etc.\n也就是说，我们可以通过Order of Growth来衡量算法效率\n但目前的分析增长规模的方式（symbolic count）不够简单，在数学上也不太严谨，所以需要将其简化：\n只看worst cast count 只选一个有代表性的操作来count 只看对order影响最大的一项，比如：n^3~~+n^2+1~~ 忽略系数 simplification/1 到这步为止，分析时需要1）计算一整个表格，2）挑出一个代表性count，3）简化。这种分析步骤还可以进一步简化：\n一种是直接看着代码，选择某个运算符进行计数 Approach1-based on exact count 更加简单的一种是几何上的分析（假设边是$N-1$，直接得出$N^2$） Approach2-simpler geometric argument Asymptotic Notation 最后介绍渐进分析的常用记号Big Theta（即Order of Growth）和Big O。\nBig theta 可以用Big Theta来描述某一程序运行时间的增长速率。\n记号 假设有一个runtime function $R(n)$，如果$R(n)$的order of growth（函数形状）是$f(N)$\n则记作： $$ R(n) \\in \\Theta (f(N)) $$\n定义 $$ R(n) \\in \\Theta (f(N)) $$\n的意思是存在正常数$k_1$, $k_2$，使得 $$ k_1 · f(n) \\leq R(N) \\leq k_2 · f(N) $$ 对$N\u0026gt;N_0$（i.e. very large N）的所有数均成立。\n举例 Big Theta demo Big O Big Theta更像是描述一种“等于”的关系（某一函数的增长速度等于xx），而Big O描述的是“小于等于”的关系。\n定义（*可以看出相比$\\Theta$是把下限去掉了） $$ R(n) \\in \\Theta (f(N)) $$\n的意思是存在正常数$k_2$，使得 $$ R(N) \\leq k_2 · f(N) $$ 对$N\u0026gt;N_0$（i.e. very large N）的所有数均成立。\n举例： $$ N^3+3N^4 \\in \\Theta(N^4) $$\n$$ N^3+3N^4 \\in O(N^6) $$\nBig O vs Big Theta Informal meaning Family Family Members Big Theta$$\\Theta(f(N))$$ Order of Growth is f(N) $\\Theta(f(N^2))$ $$N^2/2$$$$2N^2$$$$N^2+38N$$ Big O$$O(f(N))$$ Order of growth is less than or equal to f(N) $O(f(N^2))$ $$N^2/2$$$$2N^2$$$$lg(N)$$ ","permalink":"http://eimy.ink/zh/posts/2023/asymptotics-notes/","summary":"halfway through 61b!","title":"61B Notes - Asymptotics"},{"content":"因为是intel转m1，会涉及到一些软件的重装和重新配置，所以在这里备忘一下\n主要参考：https://sspai.com/post/64301\n设备情况 旧机：MBP 13\u0026rsquo; 2018 256+8 Intel i5，系统是Monterey 12.1\n新机：MBP 14\u0026rsquo; 2021 512+16 M1\n步骤 旧机准备 01 升级系统至最新版本\n实际因为不剩多少内存了，就没有升级\n备注：迁移后新机的系统版本是和旧机保持一致的！\n02 整理归档文件\u0026amp;应用\n具体完成了以下事项：\n【文件】系统性分类归档所有文件夹（以前分的太随意了） 【文件】删除“下载”和“桌面”上显然不需要的文件 【文件】删除/硬盘备份占用容量过大的文件 【文件】从用户文件夹中备份命令行工具配置文件（可选） 【应用】记录预备安装的软件（因为应用打算在新机上全部手动装） 【应用】删除基本不用的软件 顺便分享一下我目前的归档方案。\n桌面一般不放东西，下载一般乱放文件。除此以外，文稿分成以下几个文件夹：\n【ug-fdu】：UnderGrad，包含了每学年的文件夹、证书和资料以及社团和活动 【grad】gradschool 【life】：各种爱好 【work】：工作相关的 【selfedu】：自学内容+相应的作业和笔记 【misc-notes】：miscellaneous, 存放没有明确父项目的笔记或整理，未来可能会分成tech和non-tech两类 【misc-zatsu】：杂记。读笔、随笔什么的 【常用证书和照片】：时不时被要求上传的东西，比如护照、证件照、电子签名 说明：整体分为学业、生活、工作三块，因为想尽可能减少层级方便查找，所以“生活”中的笔记、自学、杂记、照片都被独立出来平行放置了。\n03 创建备份\n用的是west digital的硬盘和系统自带应用time machine\n04 退出iCloud\n退出iCloud且关闭查找我的mac 解除各种授权（可选，之后可以补救） 新机配置 01 迁移\n同一wifi连接状态下，两机打开迁移助手，选择需要迁移的文件即可。\n一些个人小故障：迁移完后旧机的触控板反应速度突然变得过于灵敏\u0026hellip;\n02 安装软件\n秉持实质极简主义，不想全部迁移以后再一个个卸载，于是新机上的所有应用软件都是一个个安装的。\n第一批安装的主要应用（用不到这些感觉浑身有bug在爬）：\nChrome Alfred 5 ClashX pro：用旧机下dmg然后drop过去 typora IINA 其他东西：\ngit：有新版本，但还是用的旧机迁移的\njdk\nPraat\nR+Rstudio\nvscode\nintellij idea\nAdobe photoshop（备忘）\nlogic\nfinal cut pro（备忘）\noffice全家桶\naldente（电池管理软件)\n03 其他设置\n桌面：系统偏好设置-桌面与屏幕保护程序 本地主机名：系统偏好设置-共享 这次给mac起了个独特又好记的名字——ipad-pro-max！ 04 软件使用测试\n测一下 git本地仓库使用 和旧机完全相同，不需要重新配置 检查各个应用的耗能 附录：遇到的问题 git和homebrew 问题描述：执行官网quickstart的命令，显示“///git: bad CPU type in executable\u0026quot;\n原因：迁移过来的旧机系统没装rosetta\n解决方案：装rosetta\n配置x86和arm的brew新名字时候出错 问题：\n1 2 › source ~/.zprofile The operation couldn’t be completed. Unable to locate a Java Runtime. 原因：看来是因为没装java\n解决：去oracle极速装了个jdk就好了。顺便这里最后没有把arm brew改成abrew，只把intel brew配置成了ibrew。\n不知道git是自带的还是迁移的版本 问题：如题\n解决：通过which git和git \u0026ndash;version确认版本和位置\n迁移旧brew软件包 解决：看这里\n","permalink":"http://eimy.ink/zh/posts/2023/mbp-setup/","summary":"再见了，所有的intel mbp(哦咩跌多パチパチ)","title":"Intel Mac迁移至M1 Mac记录"},{"content":"在整理文献时突然想看夜鹿live，于是整理了一篇攻略备用。不过有些细节是我自己查资料以后的理解，不一定准确，欢迎指正。\n01 买票 不幸的热知识 比较大的live都是抽选制，即先抽票，剩下的票才会开抢票。——欧皇才是婆罗门！ 位置都是随机的，但内场票一般都在前几轮中抽完。部分会分不同等级的指定席分价格卖。 抽票买票都需要日本手机号 基础知识 Fan Club（FC） 有些日本艺人会有自己的收费订阅制fanclub/会员俱乐部，会有特典内容、先行抽票等等福利。\n抽live票的各种途径里这应该是中奖率最高、位置最好的一种。\n「抽选者」与「同行者」问题 FC抽票时需要注意，如果抽一张票（即无同行者），那么这张票最终「使用者」需要和「抽选者」保持信息一致。说人话就是，谁抽的谁去。拿着别人名字的票有被查的风险。\n而如果是一个人用FC抽两张票，第二张票（也叫002）除非有特殊标注，一般不要求使用者身份。纸质票要求「同行者」和「抽选者」一起入场，电子票则可以直接app内转让。\n这个问题在代抽「改名字」、买二手票时都会遇到，务必弄清情况。\n开票轮次 日本live分批次开票，顺序一般为：（*有些会省略几轮）\n1）fanclub先行（会員先行），按阶级依次一轮二轮。以yrsk为例，购票人\u0026amp;同行者双会员第一批，其次是同行者非会员。\n2）艺人官网先行（オフィシャル先行）\n3）票务网站登陆者先行\n4）罗森/7-11/全家先行\n5）一般发售\n举两个例子：\n1）米津玄师2023 Tour 分为1次先行（需专辑）、2次先行（需专辑）、一般抽选\n抽过19年老米演唱会的一般抽选，没抽到。\n米津 2023 Tour 2）Yorushika 2023 「月と猫のダンス」分为会员先行1、会员先行2、官方先行\nYORUSHIKA 2023 实际操作（for大陆） 正规途径 如果有日本手机号 ==\u0026gt; 正常流程抽选 - 中选 - 支付 - 出票 etc\n没有 ==\u0026gt;正经人走什么正规途径（敲黑板）\n不太规范但更加方便的途径 一个是通过票通收二手票。票通是一个专注演出票交易的日本网站，我看下来这种方式的优点是流程正规有安全保障，价格相对透明，缺点是需要知道其中的术语潜规则，需要自己挑入手时机、自己跟卖家沟通，有时候还需要被卖家集中起来（？）一起入场，所以完全不懂日语会比较麻烦。\n票通 另一个是淘宝代抽票，比如可以搜索”pia抽票“。\n这里也分成两种，一种是商家直接帮你代抽，费用组成是商家抽票费用+（抽到了再付的）票费。这种优点是方便无脑，不过要弄清这个票是否要求「使用者身份与购票信息一致」，需要的话就意味着代抽时要提供自己的个人信息，这个就智者见智了。\n另一种是商家提供日本手机号，费用自己直接支付。这一种相当于是全程自己操作，没有任何信息泄露风险，不会有「使用者与抽选者信息不一致」的问题，但相应地会增加自己的操作成本。\n另外，推特等SNS平台也是一种渠道，这就和国内wb收票有点像，最大区别是「同行者身份」这个老问题。\n小结（TLDR） 选择你的回合——fan club抽选/一般抽选或贩卖/二手市场 选择你的英雄——各个买票渠道 不分先后 1）tb代抽（全包 ver.）\n2）tb代抽（手机号ver）\n3）通过票通/官方resale/其他二手市场收二手票\n4）用日本（朋友的）手机号正常买\n使用你的技能——在此基础上问清卖方以下问题 1）票是否要求「同行者」的身份？最最重要的问题\n2）怎么把票给我？\n3）我到现场怎么用？（需要人带or直接进）\n*如果有出票需求，还可以问二次转让的问题\n02 卖票/退票 考虑到跨国看live的时间轴长，不确定性更高，所以把卖票退票相关事宜一起整理出来。\n流程 官方原因停办：官方会退款\n个人原因去不了：\n1）提交官方转售 可搜索关键词 演唱会名字+チケットリセール or 演唱会名字+チケットトレード\n米津官方转售页 2）其他的二手市场如Mercari、雅虎拍卖、票通 或许对日语水平有一定要求\n3）tb代转卖（万能的、）\n费用及损失 官方交易 不管是退款还是官方转售，都是按照票面价给的。\n所以最终的Cost = 买入价格 - 票面价格\n二手市场 要看卖的时机和定价了，需要承担一定卖不出去的风险和与国际友人沟通造成的精神损失\ntb代卖 基本同上，还会附加tb转卖的手续费cost。\n随便举一个case 单位是rmb\n票本体：450\n收票手续： X（取决于几抽出货） * tb手续费50～70\n转卖额外：+ 手续费算100\n总共损失= 手续费100～200\n","permalink":"http://eimy.ink/zh/posts/2023/live-japan/","summary":"论文开题副产物","title":"日本Live购票攻略"},{"content":" 追记：我故意保留了一部分抽风文学，这样大家才知道我是抽象人（九转博客）\n自我介绍是为了让别人了解一个人。对于我这种习惯在大脑本地单机的人来说，可能直接展现我平常在想什么事情、打算去哪里整薯条，更能让隔着3-2-3次元壁的人快速明白我是怎样的人。\n正好也快年终了，就当是一年内思想历程的总结吧！\ntldr：是一直抽风偶尔抽象的人\n2021～2022的备忘录选 - 2021.11.15 1 权力理论与全球化语境的联系？在全球化语境里，我们怎么理解生命政治学？rf知乎\n2 如何从当代视觉文化的角度理解福柯哲学？\n（rd：居伊德波《景观社会》鲍德里亚《生产之境》布尔迪厄《实践理性》）\n个人对这个还挺感兴趣 正好景观社会也在list里\n3 权力理论与性别批评结合？\n（《性别麻烦：女性主义与身份的颠覆》《陌生的自我》）\n感觉可以和亚文化圈的问题结合起来谈\n- 2021.11.18 生理疼痛也许是防止自我客体化的最好途径（之一）精神疼痛或许也是\u0026hellip;\n膝盖的伤让我这几天深切体会到主体性，世界怎么样完全取决于我怎么样\u0026hellip;\n- 2021.11.20 把所谓的虚无主义（或类似的表述）当成自己人生信条的人，他们的生活行为大多与这一信条相矛盾。他们仍然在所谓的无价值、无意义的世界中界定价值寻求意义——他们说有些事物是好的而另一些是坏的，他们说这是正确的那是错误的，他们认为一部分是有价值的而另一部分是无意义的。从这种意义上来说，虚无主义只是他们将物质安乐与精神空虚合理化的工具，是为不经审视的权力话语准备的免责声明（甚至，掩盖自己人生的虚无的遮羞布，什么的）。\n- 2021.12.07 《胰岛素-肝锅力自律法》 又名《自律的胰岛素有多可怕》\n最近在研究一些营养学知识aka每天一则伪科学冷知识，发现竟然可以应用在日常提高效率上：\n比如盛传的间歇性断食，据说可以通过减少摄入食物的时间来增强胰岛素的敏感性，由此可以及时控制血糖，一定程度上降低患糖尿病的风险。说得通俗点就是让#您的降血糖小助手#随时待命，更加机动灵活些，防止人浸死在糖水里。\n于是我就想到自己日常的做事状态——如果把血糖类比「生活压力（学业+各种）」，胰岛素的作用对应「肝作业/完成任务以减轻压力的行为」，胰岛素处理血糖的效率（即敏感性）对应「处理压力的效率」，那么间歇性断食就可视作「在压缩过的短期内完成压力的处理，在其他时段内保持低或无压力状态，由此提升短期内压力处理效率即做事效率，防止人无时无刻泡在低效率的生活重压中」。\n（*虽然比较致命的是，血糖升高的前置行为一般给人带来快乐，而压力水平升高就\u0026hellip;当然我们不排除有人喜欢这种）\n在实际执行中，根据性格、生活方式和健康状况的不同可以有两种方法。第一是可以被拍成自律视频上传某站的提前规划按时完成剩下时间放飞自我，或者干别的。这种显然适合高Te人，但建议配合N系技能食用（ni是很好的），否则会变成沉迷执行计划，但问前程一问三不知的状态。还有一种是，ddsk的死线前夜精神小伙久坐不起原地瘫痪法，也就是把事情拖到真的来不及，被迫在短期内完成。听起来很容易，但是只有心态良好的朋友才适合。Te+Si强行整这种，估计会被致郁。\n- 2022.01.20 关于“mbti会不会变” 简单的y/n答案：会\n简单问题复杂化的解释：\n众所周知x，你测出来的mbti 和 你感知的自己的mbti 和 客观上你的人格（假设存在这种人格本体论的话）是三件事情。\n1 关于测出来的mbti会不会变\n这个问题可以类比成在问“一个人做的混合蔬果汁的风味会不会变”一样，答案是废话当然可能变，不过具体还是看人。从底层原理来说，mbti是定性或定量考察一个人八种认知思维功能以后综合得出的人格倾向，就像一杯混合蔬菜汁的综合味道由放进去的蔬菜种类比重决定一样（）继续类比，蔬菜汁的味道会随一个人【不同情况下】放的蔬菜种类和比例不同而改变，测试结果也会受各种要素影响（包括但不限于个体在测试时期主要使用的八维功能eg“我今天emo了”、测试者自己对mbti某人格的偏好eg典中典之“我一定要测成人上人intj”等等），所以mbti测出来不一样是很正常的。\n至于为什么说“具体看人”，，因为总有人持之以恒地喝400ml菠菜羽衣甘蓝汁八种功能极性强（or mbti自我感知十分坚定等等），在各种情况下测出来都差不多。\n2 关于自我感知的mbti会不会变\n答案也是有可能，但或许只是巴纳姆效应etc啥的间接结果呢？撇除被测试结果误导的情况，导致自我感知变化的可能有长期短期的【个人】因素。举几个例子。短期影响导致结果不一的例子：我原本是xntj但是我今天emo了=我陷入了Fi-Ni loop=\u0026gt;我感觉我变成了知名emo人xnfp（是用成见在举例没有冒犯的意思）。长期一点的架空例子：我本是xsfp带艺术家但自从上了高中压力贼大，每天化身学习自律人见证凌晨四点的上海，这段经历过于刻骨铭心导致自此以后我一直觉得自己是xstj。归根结底这就是看一个人对自己主要使用的功能的印象有没有变。\n3 关于客观人格类型（if any）会不会变**\n斯密马塞，纯纯知识盲区。本来我就有点被（似乎是荣格学派的）人格面具理论带跑，觉得这玩意儿老是在变，然后之前上课走马观花地听了一些social identity theory（还有social role/reresentation）以后我就更加觉得不存在一以贯之的本体人格了\nps 我过于文盲以至于都不知道把这个问题界定在社会学还是心理学还是哪里的范畴来讨论（不过似乎人格心理学是社会心理学的分支）orz只是在瞎搞一些乱七八糟的namedropping，给看到且有兴趣的赛博有缘人一些研究线索[rose emoji]\nbtw我是真的看不惯用mbti反过来去解释行为 怎么能对如此复杂的问题采取这种reductionist的方法捏..\n- 2022.03.10 考试因为疫情取消 疫情天天开盲盒封校 我算是要溺死在焦虑里了\n刚刚看完《花束般》 一些无端联想的感悟：\n保护一个爱好的最好方式或许是让它成为孤岛。最近发现任何本质是非物质的东西一旦沾染上社会性就会变质（那种艺术追求会被磨损）：我曾经很喜欢画画，但自从接过一次稿后就再也没有画过一张，甚至都不再愿意构思；我曾经很喜欢pjsk，但自从去这个游戏的组里实习过后一次游戏也没有打开过。说起来不只是我，在游戏行业失去梦想的人不计其数（所谓第九艺术也只是对于韭菜们，对商业化产品的制作者来说这大约不会是这么pure的东西，除非有一个组、一个公司的人愿意陪你一天吃三顿梦想）。这个，虽说有可能这只是correlation而不是causation，有可能只是我自己在通过丢弃沾染上mishap的事物来逃避需要长大的现实，但用来说明理想的磨损大概是够了。虽然我听到过别人说工作和爱好从来不是对立的，但是我会怀疑是否有“很多人”愿意在九十点到家后“略感疲惫”地坚持一些纯碎的事业。就我自己，甚至连回到提瓦特还是海拉鲁的力气都没有。我不觉得这是可以长存于“普通人”身上的理想主义。为什么？详情可扫描二维码添加小助手领取以下书籍《在社会里寻求梦想是否搞错了什么》《当我画画、看书、打游戏的时候，我到底在想什么？》《如果这样说的话还不清楚怎么想都是你们的问题。》你看，你无法成为“an island”，你必须先一步“大人になる”，但你也不愿意失去“无用的灵魂”，那么真相又只有一个了。\n不过话说回来，三四个月没怎么看书，文字也变得无趣，逻辑也变得无序起来，好像只是一些意识流抱怨的堆砌 斯米马赛\n- 2022.04.05 是这样的 定期输入好的作品很像是在积攒势能（实质可能是「下次一定」式创作欲）是在拯救一些生活动能耗尽失去灵魂的咸鱼 绝对不是在找借口摸鱼\n不然谁会去管什么八月翘打工月光下骑车逃跑、放学不回家在教室玩推理游戏、去斯德哥尔摩对着照片圣地巡礼、开着萝卜跟哥哥塔塔开说什么“我要亲手了结你”的怪话 这种和自己八杆子打不着的桥段！seyana\n- 2022.05.14 用别人的意见（节奏）作为价值判断的依据的等同于放弃思考。我坚决抵制“因为大家都在骂，所以它是坏的”这种思维模式。\n- 2022.08.14 最近读一些精分流派的书，最大的感受是人的精神倾向、人格风格这类性质早在幼年期就已经被决定了（不管是受到那几个时期的客体影响，还是继承自集体无意识什么的）人终其一生其实都不能也不应该压抑、改变、泯灭这些预先决定的属性，仅能学习如何控制脾性，接纳种种衍生的悲喜剧。从这个角度来看，相信存在先于本质不如相信预定论，这样还不至于活到半路突然幻灭。\n- 2022.09.12 之前想到se-te轴，总觉得是需要美食、运动这样se的象征来激发te功能，比如品尝到美食后的间歇性振作。今天突然领悟，反完美主义的「立刻行动」，或许才是se字面的、原本的涵义。\n- 2022.09.20 我会选择牺牲一部分当下的生活而活在未来。我看过去总是不那么美好的，因为它们是被牺牲的每一个当下的瞬间的集合。\n- 2022.11.13 近期发现：从认识的很多家庭案例里观察到 孩子的人格形成 和 家人的人格以及家里的权力关系相关性非常显著。粗略分似乎有积极型和消极型发展两种模式 后者是B功能的使用被压抑导致被迫向功能的另一端A发展 比如Fi被威权型家长压抑就变成Fe（倒也不一定是ti啦 前者是A功能使用时不断收到正反馈从而自然发展 我的观察是一般积极型的孩子会健全一些 消极型的扭曲程度就取决于具体是哪种人格了\u0026hellip;\n- 2022.11.15 “象征界的法则决定了我的身份，也就是说，无论我认为自己是谁，除非在象征界的机制内获得自己和他人的认可，否则这种身份认同就是不真实的。\n- 2022.11.26 发现对于「某个群体将受到一定程度的剥削」这件事 有些人在意群体的范围 有些人在意剥削程度 嗯\u0026hellip;倾向于觉得后者可能是fe高（自动代入）或者fi高（个人喜好） 前者大概是te（实践影响）和ti（合理程度）高一点\n人与人之间思维差异还是很有趣的 \u0026ndash;观察sns有感\n- 2022.12.20 アコギ和エレキ虽然都是吉他 但作为乐器好像对我来说有很不一样的性质 就像用来日常写字的钢笔和用来写硬笔书法的钢笔 应该是as means和as end的比例不一样\n- 2022.12.22 事物往往以综合的形式展现在人眼前\n但人在特定阶段的核心诉求一般都是单一而隐蔽的\n所以经常会出现这样的悲剧：一个人在零星的黑盒式案例中推定因果论 奋力追求那个选定的某个综合的“因” 但回头发现真正想要的只是其中的某个性质或部分 其余的努力被浪费在既要又要的贪婪和建巴别塔的傲慢上\n其实也不是悲剧 就是在共时的视角下没法回避的常态（意思是历时就可以解决了）\n\u0026hellip;\n","permalink":"http://eimy.ink/zh/posts/first-post/","summary":"一篇为了填充个人主页临时拼凑的自我介绍","title":"First Post"},{"content":" 假定点进这里的人想知道些别的\n关于本站 个人博客，缘起于有朋友说我很神秘.jpg\n性质更接近学习笔记和生活存档，不打算写成纯技术博客。\n关于我（in life ver.） 本科English@FDU =\u0026gt; 研究生CS@NEU\n说来话长，总之现在学得很开心。\n面包体 :\nintj 5w6 虽然当面问的话我一般说IMSB\n学习过的自然语言:\n汉语：显然 英语：托福四舍五入满分 日语：高中为了看番考了N1 法语：高中学到幼儿园水平 喜欢的乐队:\nYorushika：自其出道单推六年，拿不拿天下第一.jpg Official髭男dism：藤原聪是天才，听jpop但不听胡男的人是相对失败的 其他\n曾经闲的时候： 认真研究了很久人格心理学和精神分析 并致力于将其应用在现实中 有空会分享成果🍻 成为了木吉他三品战士，还有一把观赏用电吉他 谁没有过ギターヒーロー梦 画过插画接过稿 绘画n年归来仍是画伯 V4时代入坑Vocaloid调教，发布过几首翻调 几乎没有休息日，失踪/咕咕的原因只可能是太忙力 最后更新：2023-07\n","permalink":"http://eimy.ink/zh/about/","summary":"about","title":"关于"}]