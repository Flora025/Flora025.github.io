<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>61B Notes - B-Trees &amp; LLRB | FloraZ</title>
<meta name="keywords" content="data structure">
<meta name="description" content="B-tree, rotation and red-black trees">
<meta name="author" content="fll">
<link rel="canonical" href="http://eimy.ink/en/posts/2023/b-tree-llrb/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.3f09ba765b9df309056d4698ef69e5ff8d1e95c6d19db8f6e8faedc07b090157.css" integrity="sha256-Pwm6dlud8wkFbUaY72nl/40elcbRnbj26PrtwHsJAVc=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f83806d9904cccf883edf075a5ce1d71136879702650d07aca8c76361a3e467b.js" integrity="sha256-&#43;DgG2ZBMzPiD7fB1pc4dcRNoeXAmUNB6yox2Nho&#43;Rns="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="http://eimy.ink/favicons/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://eimy.ink/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://eimy.ink/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://eimy.ink/apple-touch-icon.png">
<link rel="mask-icon" href="http://eimy.ink/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="http://eimy.ink/posts/2023/b-tree-llrb/">
<link rel="alternate" hreflang="en" href="http://eimy.ink/en/posts/2023/b-tree-llrb/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" integrity="sha384-GvrOXuhMATgEsSwCs4smul74iXGOixntILdUW9XmUC6+HX0sLNAK3q71HotJqlAn" crossorigin="anonymous">


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js" integrity="sha384-cpW21h6RZv/phavutF+AuVYrr+dA8xD9zs6FwLpaCct6O9ctzYFfFr4dgmgccOTx" crossorigin="anonymous"></script>


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>

    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "$$", right: "$$", display: true},
                    {left: "$", right: "$", display: false}
                ]
            });
        });
    </script><meta property="og:title" content="61B Notes - B-Trees &amp; LLRB" />
<meta property="og:description" content="B-tree, rotation and red-black trees" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://eimy.ink/en/posts/2023/b-tree-llrb/" /><meta property="og:image" content="http://eimy.ink/papermod-cover.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-28T22:36:43+08:00" />
<meta property="article:modified_time" content="2023-03-28T22:36:43+08:00" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="http://eimy.ink/papermod-cover.png"/>

<meta name="twitter:title" content="61B Notes - B-Trees &amp; LLRB"/>
<meta name="twitter:description" content="B-tree, rotation and red-black trees"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://eimy.ink/en/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "61B Notes - B-Trees \u0026 LLRB",
      "item": "http://eimy.ink/en/posts/2023/b-tree-llrb/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "61B Notes - B-Trees \u0026 LLRB",
  "name": "61B Notes - B-Trees \u0026 LLRB",
  "description": "B-tree, rotation and red-black trees",
  "keywords": [
    "data structure"
  ],
  "articleBody": "Note: The passage is originally written in Chinese and translated into English via ChatGPT.\nB-Tree, LLRB Hug usually smoothly transitions and introduces new concepts, but the transitions written in the notes can be a bit verbose, so I will provide a concise version here.\nLimitations of BST First, let’s introduce two properties of BST: height and average depth. Height: Determines the worst-case runtime to find a node. Average depth: Determines the average-case runtime to find a node. Now let’s look at various properties of BSTs. Worst case: $\\Theta(N)$ height Best case: $\\Theta(\\log N)$ height Random trees have $\\Theta(\\log N)$ average depth and height (bushy). Random trees perform well, but the problem arises when we keep inserting data from the right side, leading to imbalance, such as: add(“01-Jan-2019, 10:31:00”) add(“01-Jan-2019, 18:51:00”) B-Trees / 2-3 trees / 2-3-4 trees To address the issue of imbalance, we keep inserting new keys into existing nodes and perform node splitting. This gives rise to a new type of tree called B-trees.\nB-trees should be called juicy trees.\nDefinition B-trees are self-balancing trees and can be classified into different types: B-trees of order L=3 (like the ones used today) are also called a 2-3-4 tree or a 2-4 tree (as shown in the figure). B-trees of order L=2 are also called a 2-3 tree (as shown in the figure). B-trees of larger L are used in practice for databases, etc. Construction Mechanism (node-split)\nInsert into a leaf until the number of keys exceeds L. In case of excessive keys, send the second (1st) node up and split the node. Examples:\n【No cascading reaction】 【Involves cascading reaction】 【Involves root split】 Properties (or Invariants)\nBased on the construction mechanism mentioned above, we can derive some properties of B-trees. B-trees are balanced in that:\nAll leaves must be the same distance from the source. Consider: When a root split occurs, the height increases by 1, and all nodes descend one level. If there is no root split, the height remains the same. A non-leaf node with k items must have exactly k+1 children. Runtime Analysis Height: $\\Theta(\\log N)$ for both worst-case and best-case scenarios. In the best case, each node has L items (full), so the height grows with $\\Theta(\\log_{L+1}N)$. In the worst case, each node has only 1 item, so the height grows with $\\Theta(\\log_2N)$, the same as a BST. Operation runtime: Both contains() and add() have a complexity of $O(\\log N)$. Worst case for contains(): $C = (\\text{number of layers}) \\log_{L+1}{N} \\cdot (\\text{nodes per layer}) 1 \\cdot (\\text{work per node}) L$ Worst case for add(): It involves some split operations, but the simplified complexity remains the same. Limitations of B-Trees Can you guess why the code implementation is not included above?\nLeft Leaning Red-Black Trees Definition A BST with left glue links that represents a 2-3 tree is often called a “Left Leaning Red Black Binary Search Tree” or LLRB.\nIn other words, LLRB is a BST that corresponds to a specific B-Tree. Some remarks about LLRB trees:\nLLRBs are normal BSTs! There is a one-to-one correspondence between an LLRB and an equivalent 2-3 tree. The red color is just a convenient representation. Red links don’t have any special functionality. Properties Similar to BSTs, LLRB trees have the following properties:\nAll leaves must be the same distance from the source (counting only black links). No node has two red links. Construction Mechanism In principle, LLRB trees are based on 2-3 trees, where the smaller item in a node is moved down. For example: However, it is not practical to implement a 2-3 tree and then convert it to an LLRB tree. In the code , LLRB trees are implemented directly using red links, rotation, and color flipping:\nAlways use a red link when inserting (analogous to adding items to a node in a 2-3 tree).\nWhen inserting items on the right, use rotateLeft().\nWhen inserting items on the left twice, use rotateRight().\nA new rule allows representing temporary 4-nodes as BST nodes with two red links.\nIn case of temporary 4-nodes, use flipColors().\nIf a rotation or color flip operation causes an additional violation, fix it.\nCode Implementation The following code includes the implementation of these methods, including the modified Node class, put(), the newly added rotate methods, flipColors(), and isRed().\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 // LLRB insertion (p.439) public class RedBlackBST\u003cKey extends Comparable\u003cKey\u003e, Value\u003e { private Node root; private class Node // BST node with color bit (see page 433) private boolean isRed(Node h) // See page 433. private Node rotateLeft(Node h) // See page 434. private Node rotateRight(Node h) // See page 434. private void flipColors(Node h) // See page 436. private int size() // See page 398. public void put(Key key, Value val) { // Search for key. Update value if found; grow table if new. root = put(root, key, val); root.color = BLACK; } private Node put(Node h, Key key, Value val) { if (h == null) { // Do standard insert, with red link to parent. return new Node(key, val, 1, RED); } int cmp = key.compareTo(h.key); if (cmp \u003c 0) { h.left = put(h.left, key, val); } else if (cmp \u003e 0) { h.right = put(h.right, key, val); } else { h.val = val; } if (isRed(h.right) \u0026\u0026 !isRed(h.left)) { // 基于BST只需要修改这里三个clause h = rotateLeft(h); } if (isRed(h.left) \u0026\u0026 isRed(h.left.left)) { h = rotateRight(h); } if (isRed(h.left) \u0026\u0026 isRed(h.right)) { flipColors(h); h.N = size(h.left) + size(h.right) + 1; return h; } } // some omitted methods within RedBlackBST Class private boolean isRed(Node x) { if (x == null) return false; return x.color == RED; } private Node rotateLeft(Node h) { // rotateRight() is similar Node x = h.right; h.right = x.left; x.left = h; x.color = h.color; h.color = RED; x.N = h.N; h.N = 1 + size(h.left) + size(h.right); return x; } private void flipColors(Node h) { h.color = RED; h.left.color = BLACK; h.right.color = BLACK; } } // delete比较麻烦，详细见p.441. Runtime Analysis Height: $O(logN)$ contains(): $O(logN)$ insert(): $O(logN)$ $O(logN)$ to add the new node $O(logN)$ for rotation and color flip operations per insert （After simplification and ignoring constant terms, the time complexity remains O(log N).） Summary of search trees 逻辑梳理 Cited from the slides [lec 18, 19sp]\nBinary search trees** are simple, but they are subject to imbalance.\n2-3 Trees (B Trees) are balanced, but painful to implement and relatively slow.\nLLRBs insertion is simple to implement (but delete is hard).\nWorks by maintaining mathematical bijection with a 2-3 trees. Java’s TreeMap is a red-black tree (not left leaning).\nMaintains correspondence with 2-3-4 tree (is not a 1-1 correspondence).\nAllows glue links on either side (see Red-Black Tree).\nMore complex implementation, but significantly (?) faster.\nComplexity/runtime对比 WC = worst case\nBST B-Trees LLRB Height $O(logN)$ $\\Theta(logN)$ $O(logN)$ WC：$O(N)$ WC：$O(log N)$ WC：$O(log N)$ contains() $O(logN)$ $O(log N)$ $O(logN)$ WC：$O(N)$ WC：$O(log N)$ WC：$O(log N)$ insert() $O(logN)$ $O(log N)$ $O(logN)$ WC：$O(N)$ WC：$O(log N)$ WC：$O(log N)$ Explanation: B-trees and LLRB trees are self-balanced, which prevents the extreme case of a BST degenerating into a linked list. This property makes them faster compared to regular BSTs. In summary:\nB-trees achieve self-balancing to avoid the worst-case complexity of regular BSTs. LLRB trees not only inherit the self-balancing property of B-trees but also retain the ease of implementation characteristic of regular BSTs. ",
  "wordCount" : "1276",
  "inLanguage": "en",
  "datePublished": "2023-03-28T22:36:43+08:00",
  "dateModified": "2023-03-28T22:36:43+08:00",
  "author":{
    "@type": "Person",
    "name": "fll"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://eimy.ink/en/posts/2023/b-tree-llrb/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "FloraZ",
    "logo": {
      "@type": "ImageObject",
      "url": "http://eimy.ink/favicons/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://eimy.ink/en/" accesskey="h" title="FloraZ (Alt + H)">FloraZ</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                    <li>
                        <a href="http://eimy.ink/" title="中文"
                            aria-label="中文">中文</a>
                    </li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://eimy.ink/en/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="http://eimy.ink/en/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="http://eimy.ink/en/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="http://eimy.ink/en/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="http://eimy.ink/en/about/" title="About">
                    <span>About</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main post">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://eimy.ink/en/">Home</a>&nbsp;»&nbsp;<a href="http://eimy.ink/en/posts/">Posts</a></div>
    <h1 class="post-title">
      61B Notes - B-Trees &amp; LLRB
    </h1>
    <div class="post-meta"><span title='2023-03-28 22:36:43 +0800 +0800'>March 28, 2023</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;fll&nbsp;|&nbsp;Translations:
<ul class="i18n_list">
    <li>
        <a href="http://eimy.ink/posts/2023/b-tree-llrb/">中文</a>
    </li>
</ul>

</div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">Table of Contents</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#b-tree-llrb" aria-label="B-Tree, LLRB">B-Tree, LLRB</a><ul>
                            
                    <li>
                        <a href="#limitations-of-bst" aria-label="Limitations of BST">Limitations of BST</a></li>
                    <li>
                        <a href="#b-trees--2-3-trees--2-3-4-trees" aria-label="B-Trees / 2-3 trees / 2-3-4 trees">B-Trees / 2-3 trees / 2-3-4 trees</a><ul>
                            
                    <li>
                        <a href="#definition" aria-label="Definition">Definition</a></li>
                    <li>
                        <a href="#construction-mechanism" aria-label="Construction Mechanism">Construction Mechanism</a></li>
                    <li>
                        <a href="#properties" aria-label="Properties">Properties</a></li>
                    <li>
                        <a href="#runtime-analysis" aria-label="Runtime Analysis">Runtime Analysis</a></li>
                    <li>
                        <a href="#limitations-of-b-trees" aria-label="Limitations of B-Trees">Limitations of B-Trees</a></li></ul>
                    </li>
                    <li>
                        <a href="#left-leaning-red-black-trees" aria-label="Left Leaning Red-Black Trees">Left Leaning Red-Black Trees</a><ul>
                            
                    <li>
                        <a href="#definition-1" aria-label="Definition">Definition</a></li>
                    <li>
                        <a href="#properties-1" aria-label="Properties">Properties</a></li>
                    <li>
                        <a href="#construction-mechanism-1" aria-label="Construction Mechanism">Construction Mechanism</a></li>
                    <li>
                        <a href="#code-implementation" aria-label="Code Implementation">Code Implementation</a></li>
                    <li>
                        <a href="#runtime-analysis-1" aria-label="Runtime Analysis">Runtime Analysis</a></li></ul>
                    </li>
                    <li>
                        <a href="#summary-of-search-trees" aria-label="Summary of search trees">Summary of search trees</a><ul>
                            
                    <li>
                        <a href="#%e9%80%bb%e8%be%91%e6%a2%b3%e7%90%86" aria-label="逻辑梳理">逻辑梳理</a></li>
                    <li>
                        <a href="#complexityruntime%e5%af%b9%e6%af%94" aria-label="Complexity/runtime对比">Complexity/runtime对比</a>
                    </li>
                </ul>
                </li>
                </ul>
                </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>

  <div class="post-content"><p>Note: The passage is originally written in Chinese and translated into English via ChatGPT.</p>
<hr>
<h1 id="b-tree-llrb">B-Tree, LLRB<a hidden class="anchor" aria-hidden="true" href="#b-tree-llrb">#</a></h1>
<p>Hug usually smoothly transitions and introduces new concepts, but the transitions written in the notes can be a bit verbose, so I will provide a concise version here.</p>
<h2 id="limitations-of-bst">Limitations of BST<a hidden class="anchor" aria-hidden="true" href="#limitations-of-bst">#</a></h2>
<ul>
<li>First, let&rsquo;s introduce two properties of BST: height and average depth.
<ul>
<li>Height: Determines the worst-case runtime to find a node.</li>
<li>Average depth: Determines the average-case runtime to find a node.</li>
</ul>
</li>
</ul>
<center>
<img style="border-radius: 0.3125em;
box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);zoom:40%;"
src="./B-Tree-LLRB.assets/image-20230328095936843.png">
</center>
<ul>
<li>Now let&rsquo;s look at various properties of BSTs.
<ul>
<li>Worst case: $\Theta(N)$ height</li>
<li>Best case: $\Theta(\log N)$ height</li>
<li>Random trees have $\Theta(\log N)$ average depth and height (bushy).</li>
</ul>
</li>
<li>Random trees perform well, but the problem arises when we keep inserting data from the right side, leading to imbalance, such as:
<ul>
<li>add(&ldquo;01-Jan-2019, 10:31:00&rdquo;)</li>
<li>add(&ldquo;01-Jan-2019, 18:51:00&rdquo;)</li>
</ul>
</li>
</ul>
<h2 id="b-trees--2-3-trees--2-3-4-trees">B-Trees / 2-3 trees / 2-3-4 trees<a hidden class="anchor" aria-hidden="true" href="#b-trees--2-3-trees--2-3-4-trees">#</a></h2>
<p>To address the issue of imbalance, we keep inserting new keys into existing nodes and perform node splitting. This gives rise to a new type of tree called B-trees.</p>
<blockquote>
<p>B-trees should be called juicy trees.</p>
</blockquote>
<h3 id="definition">Definition<a hidden class="anchor" aria-hidden="true" href="#definition">#</a></h3>
<ul>
<li>B-trees are self-balancing trees and can be classified into different types:
<ul>
<li>B-trees of order L=3 (like the ones used today) are also called a 2-3-4 tree or a 2-4 tree (as shown in the figure).</li>
<li>B-trees of order L=2 are also called a 2-3 tree (as shown in the figure).</li>
<li>B-trees of larger L are used in practice for databases, etc.</li>
</ul>
</li>
</ul>
<img src="./image-20230328102217909.png#center" alt="image-20230328102217909" style="zoom:50%;" />
<h3 id="construction-mechanism">Construction Mechanism<a hidden class="anchor" aria-hidden="true" href="#construction-mechanism">#</a></h3>
<p>(node-split)</p>
<ul>
<li>
<ol>
<li>Insert into a leaf until the number of keys exceeds L.</li>
</ol>
</li>
<li>
<ol start="2">
<li>In case of excessive keys, send the second (1st) node up and split the node.</li>
</ol>
</li>
</ul>
<p>Examples:</p>
<center>【No cascading reaction】</center>
<center>
<img style="border-radius: 0.3125em;
box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);zoom:40%;"
src="./B-Tree-LLRB.assets/image-20230328103007573.png">
</center>
<center>【Involves cascading reaction】</center>
<center>
<img style="border-radius: 0.3125em;
box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);zoom:40%;"
src="./B-Tree-LLRB.assets/image-20230328103228293.png">
</center>
<center>【Involves root split】</center>
<center>
<img style="border-radius: 0.3125em;
box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);zoom:40%;"
src="./B-Tree-LLRB.assets/image-20230328103520808.png">
</center>
<h3 id="properties">Properties<a hidden class="anchor" aria-hidden="true" href="#properties">#</a></h3>
<p>(or Invariants)</p>
<p>Based on the construction mechanism mentioned above, we can derive some properties of B-trees. B-trees are balanced in that:</p>
<ul>
<li>All leaves must be the same distance from the source.
<ul>
<li>Consider: When a root split occurs, the height increases by 1, and all nodes descend one level.</li>
<li>If there is no root split, the height remains the same.</li>
</ul>
</li>
<li>A non-leaf node with k items must have exactly k+1 children.</li>
</ul>
<h3 id="runtime-analysis">Runtime Analysis<a hidden class="anchor" aria-hidden="true" href="#runtime-analysis">#</a></h3>
<ul>
<li>Height: $\Theta(\log N)$ for both worst-case and best-case scenarios.
<ul>
<li>In the best case, each node has L items (full), so the height grows with $\Theta(\log_{L+1}N)$.</li>
<li>In the worst case, each node has only 1 item, so the height grows with $\Theta(\log_2N)$, the same as a BST.</li>
</ul>
</li>
<li>Operation runtime: Both <code>contains()</code> and <code>add()</code> have a complexity of $O(\log N)$.
<ul>
<li>Worst case for <code>contains()</code>: $C = (\text{number of layers}) \log_{L+1}{N} \cdot (\text{nodes per layer}) 1 \cdot (\text{work per node}) L$</li>
<li>Worst case for <code>add()</code>: It involves some split operations, but the simplified complexity remains the same.</li>
</ul>
</li>
</ul>
<center>
<img style="border-radius: 0.3125em;
box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);zoom:40%;"
src="./B-Tree-LLRB.assets/image-20230328115018100.png">
</center>
<h3 id="limitations-of-b-trees">Limitations of B-Trees<a hidden class="anchor" aria-hidden="true" href="#limitations-of-b-trees">#</a></h3>
<blockquote>
<p>Can you guess why the code implementation is not included above?</p>
</blockquote>
<h2 id="left-leaning-red-black-trees">Left Leaning Red-Black Trees<a hidden class="anchor" aria-hidden="true" href="#left-leaning-red-black-trees">#</a></h2>
<h3 id="definition-1">Definition<a hidden class="anchor" aria-hidden="true" href="#definition-1">#</a></h3>
<p>A BST with left glue links that represents a 2-3 tree is often called a &ldquo;Left Leaning Red Black Binary Search Tree&rdquo; or LLRB.</p>
<p>In other words, LLRB is a BST that corresponds to a specific B-Tree. Some remarks about LLRB trees:</p>
<ul>
<li>LLRBs are normal BSTs!</li>
<li>There is a one-to-one correspondence between an LLRB and an equivalent 2-3 tree.</li>
<li>The red color is just a convenient representation. Red links don&rsquo;t have any special functionality.</li>
</ul>
<h3 id="properties-1">Properties<a hidden class="anchor" aria-hidden="true" href="#properties-1">#</a></h3>
<p>Similar to BSTs, LLRB trees have the following properties:</p>
<ul>
<li>All leaves must be the same distance from the source (counting only black links).</li>
<li>No node has two red links.</li>
</ul>
<h3 id="construction-mechanism-1">Construction Mechanism<a hidden class="anchor" aria-hidden="true" href="#construction-mechanism-1">#</a></h3>
<ul>
<li>In principle, LLRB trees are based on 2-3 trees, where the smaller item in a node is moved down. For example:</li>
</ul>
<center>
<img style="border-radius: 0.3125em;
box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);zoom:40%;"
src="./B-Tree-LLRB.assets/image-20230328202825231.png">
</center>
<ul>
<li>However, it is not practical to implement a 2-3 tree and then convert it to an LLRB tree. In the code</li>
</ul>
<p>, LLRB trees are implemented directly using red links, rotation, and color flipping:</p>
<ul>
<li>
<p>Always use a red link when inserting (analogous to adding items to a node in a 2-3 tree).</p>
<img src="./image-20230328211407567.png#center" alt="image-20230328211407567" style="zoom:50%;" />
</li>
<li>
<p>When inserting items on the right, use <code>rotateLeft()</code>.</p>
<img src="./image-20230328211424939.png#center" alt="image-20230328211424939" style="zoom:50%;" />
</li>
<li>
<p>When inserting items on the left twice, use <code>rotateRight()</code>.</p>
<img src="./image-20230328212334776.png#center" alt="image-20230328212334776" style="zoom:50%;" />
</li>
<li>
<p>A new rule allows representing temporary 4-nodes as BST nodes with two red links.</p>
<img src="./image-20230328212423779.png#center" alt="image-20230328212423779" style="zoom:50%;" />
</li>
<li>
<p>In case of temporary 4-nodes, use <code>flipColors()</code>.</p>
</li>
<li>
<p>If a rotation or color flip operation causes an additional violation, fix it.</p>
<img src="./image-20230328213407205.png#center" alt="image-20230328213407205" style="zoom:50%;" />
<img src="./image-20230328213419511.png#center" alt="image-20230328213419511" style="zoom:50%;" />
</li>
</ul>
<h3 id="code-implementation">Code Implementation<a hidden class="anchor" aria-hidden="true" href="#code-implementation">#</a></h3>
<p>The following code includes the implementation of these methods, including the modified <code>Node</code> class, <code>put()</code>, the newly added <code>rotate</code> methods, <code>flipColors()</code>, and <code>isRed()</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="c1">// LLRB insertion (p.439)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">RedBlackBST</span><span class="o">&lt;</span><span class="n">Key</span> <span class="kd">extends</span> <span class="n">Comparable</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;,</span> <span class="n">Value</span><span class="o">&gt;</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">Node</span> <span class="n">root</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">class</span> <span class="nc">Node</span> <span class="c1">// BST node with color bit (see page 433)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">isRed</span><span class="o">(</span><span class="n">Node</span> <span class="n">h</span><span class="o">)</span>    <span class="c1">// See page 433.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">private</span> <span class="n">Node</span> <span class="nf">rotateLeft</span><span class="o">(</span><span class="n">Node</span> <span class="n">h</span><span class="o">)</span>  <span class="c1">// See page 434.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">private</span> <span class="n">Node</span> <span class="nf">rotateRight</span><span class="o">(</span><span class="n">Node</span> <span class="n">h</span><span class="o">)</span> <span class="c1">// See page 434.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">flipColors</span><span class="o">(</span><span class="n">Node</span> <span class="n">h</span><span class="o">)</span>  <span class="c1">// See page 436.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">size</span><span class="o">()</span>               <span class="c1">// See page 398.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">put</span><span class="o">(</span><span class="n">Key</span> <span class="n">key</span><span class="o">,</span> <span class="n">Value</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>  
</span></span><span class="line"><span class="cl">        <span class="c1">// Search for key. Update value if found; grow table if new.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">root</span> <span class="o">=</span> <span class="n">put</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">root</span><span class="o">.</span><span class="na">color</span> <span class="o">=</span> <span class="n">BLACK</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">Node</span> <span class="nf">put</span><span class="o">(</span><span class="n">Node</span> <span class="n">h</span><span class="o">,</span> <span class="n">Key</span> <span class="n">key</span><span class="o">,</span> <span class="n">Value</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(</span><span class="n">h</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>  <span class="o">{</span> <span class="c1">// Do standard insert, with red link to parent.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>           <span class="k">return</span> <span class="k">new</span> <span class="n">Node</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">val</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="n">RED</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">cmp</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">key</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(</span><span class="n">cmp</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">h</span><span class="o">.</span><span class="na">left</span>  <span class="o">=</span> <span class="n">put</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">left</span><span class="o">,</span>  <span class="n">key</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">cmp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">h</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">put</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">h</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">val</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span> <span class="k">if</span> <span class="o">(</span><span class="n">isRed</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">right</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">isRed</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">left</span><span class="o">))</span> <span class="o">{</span> <span class="c1">// 基于BST只需要修改这里三个clause
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">h</span> <span class="o">=</span> <span class="n">rotateLeft</span><span class="o">(</span><span class="n">h</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span> <span class="k">if</span> <span class="o">(</span><span class="n">isRed</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">isRed</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">left</span><span class="o">))</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">h</span> <span class="o">=</span> <span class="n">rotateRight</span><span class="o">(</span><span class="n">h</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span> <span class="k">if</span> <span class="o">(</span><span class="n">isRed</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">isRed</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">right</span><span class="o">))</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">flipColors</span><span class="o">(</span><span class="n">h</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">h</span><span class="o">.</span><span class="na">N</span> <span class="o">=</span> <span class="n">size</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">+</span> <span class="n">size</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">right</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">h</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// some omitted methods within RedBlackBST Class
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">isRed</span><span class="o">(</span><span class="n">Node</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">       <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">       <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="na">color</span> <span class="o">==</span> <span class="n">RED</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">Node</span> <span class="nf">rotateLeft</span><span class="o">(</span><span class="n">Node</span> <span class="n">h</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// rotateRight() is similar
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>       <span class="n">Node</span> <span class="n">x</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">       <span class="n">h</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">       <span class="n">x</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">h</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">       <span class="n">x</span><span class="o">.</span><span class="na">color</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="na">color</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">       <span class="n">h</span><span class="o">.</span><span class="na">color</span> <span class="o">=</span> <span class="n">RED</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">       <span class="n">x</span><span class="o">.</span><span class="na">N</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="na">N</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">       <span class="n">h</span><span class="o">.</span><span class="na">N</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">size</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">left</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">               <span class="o">+</span> <span class="n">size</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">       <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">flipColors</span><span class="o">(</span><span class="n">Node</span> <span class="n">h</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">       <span class="n">h</span><span class="o">.</span><span class="na">color</span> <span class="o">=</span> <span class="n">RED</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">       <span class="n">h</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">color</span> <span class="o">=</span> <span class="n">BLACK</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">       <span class="n">h</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">color</span> <span class="o">=</span> <span class="n">BLACK</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// delete比较麻烦，详细见p.441.
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="runtime-analysis-1">Runtime Analysis<a hidden class="anchor" aria-hidden="true" href="#runtime-analysis-1">#</a></h3>
<ul>
<li>Height:  $O(logN)$</li>
<li><code>contains()</code>:  $O(logN)$</li>
<li><code>insert()</code>:  $O(logN)$
<ul>
<li>$O(logN)$  to add the new node</li>
<li>$O(logN)$  for rotation and color flip operations per insert （After simplification and ignoring constant terms, the time complexity remains O(log N).）</li>
</ul>
</li>
</ul>
<h2 id="summary-of-search-trees">Summary of search trees<a hidden class="anchor" aria-hidden="true" href="#summary-of-search-trees">#</a></h2>
<h3 id="逻辑梳理">逻辑梳理<a hidden class="anchor" aria-hidden="true" href="#逻辑梳理">#</a></h3>
<blockquote>
<p>Cited from the slides [lec 18, 19sp]</p>
</blockquote>
<ul>
<li>
<p>Binary search trees** are simple, but they are subject to imbalance.</p>
</li>
<li>
<p><strong>2-3 Trees (B Trees)</strong> are balanced, but painful to implement and relatively slow.</p>
</li>
<li>
<p><strong>LLRBs</strong> insertion is simple to implement (but delete is hard).</p>
<ul>
<li>Works by maintaining mathematical bijection with a 2-3 trees.</li>
</ul>
</li>
<li>
<p>Java’s TreeMap is a red-black tree (not left leaning).</p>
<ul>
<li>
<p>Maintains correspondence with 2-3-4 tree (is not a 1-1 correspondence).</p>
</li>
<li>
<p>Allows glue links on either side (see Red-Black Tree).</p>
</li>
<li>
<p>More complex implementation, but significantly (?) faster.</p>
</li>
</ul>
</li>
</ul>
<h3 id="complexityruntime对比">Complexity/runtime对比<a hidden class="anchor" aria-hidden="true" href="#complexityruntime对比">#</a></h3>
<p>WC = worst case</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">BST</th>
<th style="text-align:center">B-Trees</th>
<th style="text-align:center">LLRB</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>Height</strong></td>
<td style="text-align:center">$O(logN)$</td>
<td style="text-align:center">$\Theta(logN)$</td>
<td style="text-align:center">$O(logN)$</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">WC：$O(N)$</td>
<td style="text-align:center">WC：$O(log N)$</td>
<td style="text-align:center">WC：$O(log N)$</td>
</tr>
<tr>
<td style="text-align:center"><code>contains()</code></td>
<td style="text-align:center">$O(logN)$</td>
<td style="text-align:center">$O(log N)$</td>
<td style="text-align:center">$O(logN)$</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">WC：$O(N)$</td>
<td style="text-align:center">WC：$O(log N)$</td>
<td style="text-align:center">WC：$O(log N)$</td>
</tr>
<tr>
<td style="text-align:center"><code>insert()</code></td>
<td style="text-align:center">$O(logN)$</td>
<td style="text-align:center">$O(log N)$</td>
<td style="text-align:center">$O(logN)$</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">WC：$O(N)$</td>
<td style="text-align:center">WC：$O(log N)$</td>
<td style="text-align:center">WC：$O(log N)$</td>
</tr>
</tbody>
</table>
<ul>
<li>Explanation: B-trees and LLRB trees are self-balanced, which prevents the extreme case of a BST degenerating into a linked list. This property makes them faster compared to regular BSTs.</li>
</ul>
<p>In summary:</p>
<ul>
<li>B-trees achieve self-balancing to avoid the worst-case complexity of regular BSTs.</li>
<li>LLRB trees not only inherit the self-balancing property of B-trees but also retain the ease of implementation characteristic of regular BSTs.</li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://eimy.ink/en/tags/data-structure/">data structure</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="http://eimy.ink/en/posts/2023/gitlet-fin/">
    <span class="title">« Prev</span>
    <br>
    <span>Notes and Thoughts on CS61B Gitlet</span>
  </a>
  <a class="next" href="http://eimy.ink/en/posts/2023/bst/">
    <span class="title">Next »</span>
    <br>
    <span>61B Notes - ADT and BST</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="http://eimy.ink/en/">FloraZ</a></span><span style="display: inline-block; margin-left: 1em;">
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/reorx/hugo-PaperMod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
  (function() {
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    const disableSmoothScroll = '' == '1';
    const enableInstantClick = '' == '1';
    
    if (window.matchMedia('(prefers-reduced-motion: reduce)').matches || disableSmoothScroll || enableInstantClick) {
      return;
    }
    
    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                behavior: "smooth"
            });
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });
  })();
</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = 'copy';

        function copyingDone() {
            copybutton.innerText = 'copied!';
            setTimeout(() => {
                copybutton.innerText = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
<script>
window.addEventListener('DOMContentLoaded', function (event) {
  const headings = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id]');
  const activeClass = 'active';

  
  let activeHeading = headings[0];
  getLinkByHeading(activeHeading).classList.add(activeClass);

  const onScroll = () => {
    const passedHeadings = [];
    for (const h of headings) {
      
      if (getOffsetTop(h) < 5) {
        passedHeadings.push(h)
      } else {
        break;
      }
    }
    if (passedHeadings.length > 0) {
      newActiveHeading = passedHeadings[passedHeadings.length - 1];
    } else {
      newActiveHeading = headings[0];
    }
    if (activeHeading != newActiveHeading) {
      getLinkByHeading(activeHeading).classList.remove(activeClass);
      activeHeading = newActiveHeading;
      getLinkByHeading(activeHeading).classList.add(activeClass);
    }
  }

  let timer = null;
  window.addEventListener('scroll', () => {
    if (timer !== null) {
      clearTimeout(timer)
    }
    timer = setTimeout(onScroll, 50)
  }, false);

  function getLinkByHeading(heading) {
    const id = encodeURI(heading.getAttribute('id')).toLowerCase();
    return document.querySelector(`.toc ul li a[href="#${id}"]`);
  }

  function getOffsetTop(heading) {
    if (!heading.getClientRects().length) {
      return 0;
    }
    let rect = heading.getBoundingClientRect();
    return rect.top
  }
}, false);
</script></body>

</html>
