<!DOCTYPE html>
<html lang="en" dir="auto" translate="no">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>xv6: Lab 3 pgtbl Notes | FloraZ</title>
<meta name="keywords" content="Operating System">
<meta name="description" content="MIT 6.S081 Lab3 Pagetable">
<meta name="author" content="fll">
<link rel="canonical" href="http://eimy.ink/en/posts/2023/xv6/lab-pgtbl/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.3f09ba765b9df309056d4698ef69e5ff8d1e95c6d19db8f6e8faedc07b090157.css" integrity="sha256-Pwm6dlud8wkFbUaY72nl/40elcbRnbj26PrtwHsJAVc=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f83806d9904cccf883edf075a5ce1d71136879702650d07aca8c76361a3e467b.js" integrity="sha256-&#43;DgG2ZBMzPiD7fB1pc4dcRNoeXAmUNB6yox2Nho&#43;Rns="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="http://eimy.ink/favicons/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://eimy.ink/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://eimy.ink/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://eimy.ink/apple-touch-icon.png">
<link rel="mask-icon" href="http://eimy.ink/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="http://eimy.ink/posts/2023/xv6/lab-pgtbl/">
<link rel="alternate" hreflang="en" href="http://eimy.ink/en/posts/2023/xv6/lab-pgtbl/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<meta property="og:title" content="xv6: Lab 3 pgtbl Notes" />
<meta property="og:description" content="MIT 6.S081 Lab3 Pagetable" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://eimy.ink/en/posts/2023/xv6/lab-pgtbl/" /><meta property="og:image" content="http://eimy.ink/papermod-cover.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-25T18:43:10-04:00" />
<meta property="article:modified_time" content="2023-09-25T18:43:10-04:00" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="http://eimy.ink/papermod-cover.png"/>

<meta name="twitter:title" content="xv6: Lab 3 pgtbl Notes"/>
<meta name="twitter:description" content="MIT 6.S081 Lab3 Pagetable"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://eimy.ink/en/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "xv6: Lab 3 pgtbl Notes",
      "item": "http://eimy.ink/en/posts/2023/xv6/lab-pgtbl/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "xv6: Lab 3 pgtbl Notes",
  "name": "xv6: Lab 3 pgtbl Notes",
  "description": "MIT 6.S081 Lab3 Pagetable",
  "keywords": [
    "Operating System"
  ],
  "articleBody": " Translation WIP: written in Chinese.\nLab url：https://pdos.csail.mit.edu/6.828/2020/labs/pgtbl.html\ncourse site：https://pdos.csail.mit.edu/6.828/2020/schedule.html\ngdb usage：https://pdos.csail.mit.edu/6.1810/2022/labs/gdb.html\n3.1 Print a page table 1 具体要求 要求实现一个vmprint()函数，接受一个pagetable参数，按照要求的格式打印出这个pagetable。\n1 2 3 4 5 6 7 # Print Format: # page table [argument] page table 0x0000000087f6e000 # [depth] [pte index]: [pagetable entry] pa [physical address] ..0: pte 0x0000000021fda801 pa 0x0000000087f6a000 .. ..0: pte 0x0000000021fda401 pa 0x0000000087f69000 .. .. ..0: pte 0x0000000021fdac1f pa 0x0000000087f6b000 2 实现方法 这个task相关的知识点：\nVA, PA, PPN, PTE的构成、作用和它们之间的关系，比如 虚拟地址（VA）中包括27bits，其中每9bits对应一个page table entry（PTE） VA包含几个部分，其中27位（3*9）用于在各层页表中索引PTE，另有12位offset用来在PA中索引定位 页表PTE中的PPN用来寻找下一层页表 xv6页表的three-level tree结构 (xv6book, p.30-1)： VA-PA转换的逻辑是：最上层页表的地址是由satp寄存器记录的；通过va中27bits里最左的9bits索引，查找到最上层的页表中对应的PTE；然后通过这个PTE中的PPN找到第二个页表，由VA中第二个9bits索引到对应的PTE，以此类推…最后再结合VA中的offset定位PA VA-PA translation是由硬件memory management unit（MMU）实现的（如果没听错，lec里说软件也可以，但是硬件更快） 如何判断PPN映射到了下一层页表还是物理内存？ 参考freewalk()，如果(pte \u0026 (PTE_R|PTE_W|PTE_X)) == 0，即不可读/写/执行，就说明PPN没有映射到物理内存，而是映射到了更低层的页表 有三层pagetable，我选择了递归打印。这个task标了easy难度，跟着hints就能实现。代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 // helper function for vmprint void printhelper(pagetable_t pagetable, int depth) { // there are 2^9 = 512 PTEs in a page table. for(int i = 0; i \u003c 512; i++){ pte_t pte = pagetable[i]; // skip invalid pages if (!(pte \u0026 PTE_V)) { continue; } // print indentation for (int i = 0; i \u003c= depth; i++) { printf(\"..\"); if(i != depth) { printf(\" \"); } } printf(\"%d: pte %p pa %p\\n\", i, pte, PTE2PA(pte)); // has lower-level pt -\u003e recursive call on child if((pte \u0026 (PTE_R|PTE_W|PTE_X)) == 0){ uint64 child = PTE2PA(pte); printhelper((pagetable_t)child, depth + 1); } } } // print the content of a page table void vmprint(pagetable_t pagetable) { // refer to freewalk() printf(\"page table %p\\n\", pagetable); printhelper(pagetable, 0); } 3 结果 和要求print内容一致，test ok。\n4 问题\u0026思考 最后有个challenge question问打印出来的page0、page1、page2里是什么。\n因为vmprint是在kernel/exec.c中调用的，所以回去看kernel/exec.c里有分配页表的地方，源码上面有注释：\n1 2 3 4 5 6 7 8 9 10 11 ... // 分配了1 page // Load program into memory. 那这个页表应该是data+text if((sz1 = uvmalloc(pagetable, sz, ph.vaddr + ph.memsz)) == 0) goto bad; ... // 分配了2 pages // Allocate two pages at the next page boundary. // Use the second as the user stack. if((sz1 = uvmalloc(pagetable, sz, sz + 2*PGSIZE)) == 0) goto bad; 所以根据Figure3.4，这些应该是init user stack时分配的，page0是data+text，page1是guard page（PTE_V not set, 不可read/write），page2是顶上的stack。\n3.2 A kernel page table per process 1 要求 让每个进程都有一个自己的kernel pagetable，它们的页表和global kernel page保持一致。在切换进程时，也要切换到该进程对应的kernel pagetable（无进程运行时用global kernel pagetable。\n和当前task相关的知识点：\n每个进程维护一个页表的用户地址空间和一个页表的内核地址空间：“Xv6 maintains one page table per process, describing each process’s user address space, plus a single page table that describes the kernel’s address space.” (xv6book, p.31) Figure 3.3 内核地址空间里的映射关系（明白这点才知道之后如何构建kernel pagetable的mapping），里面哪些是直接映射、哪些不是（和后面的kstack有关）。 以及上面的页表结构，还会再次用到 2 实现方法 和hints给的顺序基本一致：\n声明kernel pagetable变量：在 struct proc 中增加变量pagetable_t kpagetable，由此每个process都有了自己的kpt 1 2 3 4 5 6 // kernel/proc.h 结构体里增加一个变量 struct proc { // ... private pagetable_t kpagetable; // (+) Kernel page table } 仿照kvminit 写一个函数，用来创建kpagetable页表并构建映射： 理解：要在分配进程（即allocproc()里）时，增加「给kpagetable分配内存」 -\u003e 「直接映射到和global kernel pagetable相同物理地址」这些构建操作 思路：这些功能在kvminit中已有类似实现，但是不能直接调用kvminit，因为它调用了kvmmap()，后者是用mappages direct map了global kernel page和对应的pa。这里是要map各个进程的kernel page和pa，所以需要另写一个和kvmmap类似、但是允许传入指定pagetable的函数，然后在构建kpagetable时调用。 实现： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 // kernel/vm.c 实现一个类似kvmmap的函数 // +++++++以下都是新增的 // add a mapping to a given page table void uvmmap(pagetable_t pt, uint64 va, uint64 pa, uint64 sz, int perm) { if(mappages(pt, va, sz, pa, perm) != 0) panic(\"uvmmap\"); } // 参考了kvminit, // 把kvmmap换成了上面的uvm以自定义需要map的pagetable // Create a kernel page table for a given process pagetable_t proc_kpagetable(struct proc *p) { pagetable_t kpagetable = (pagetable_t) kalloc(); memset(kpagetable, 0, PGSIZE); // uart registers uvmmap(kpagetable, UART0, UART0, PGSIZE, PTE_R | PTE_W); // virtio mmio disk interface uvmmap(kpagetable, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W); // CLINT uvmmap(kpagetable, CLINT, CLINT, 0x10000, PTE_R | PTE_W); // PLIC uvmmap(kpagetable, PLIC, PLIC, 0x400000, PTE_R | PTE_W); // map kernel text executable and read-only. uvmmap(kpagetable, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X); // map kernel data and the physical RAM we'll make use of. uvmmap(kpagetable, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W); // map the trampoline for trap entry/exit to // the highest virtual address in the kernel. uvmmap(kpagetable, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X); return kpagetable; } // +++++++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // kernel/proc.c 新增代码片段 // Look in the process table for an UNUSED proc. // If found, initialize state required to run in the kernel, // and return with p-\u003elock held. // If there are no free procs, or a memory allocation fails, return 0. static struct proc* allocproc(void) { // .... // An empty user page table. p-\u003epagetable = proc_pagetable(p); if(p-\u003epagetable == 0){ freeproc(p); release(\u0026p-\u003elock); return 0; } // +++++++++++ // Create a kernel page table. p-\u003ekpagetable = proc_kpagetable(p); // 在这里调用 if(p-\u003ekpagetable == 0){ freeproc(p); release(\u0026p-\u003elock); return 0; } // +++++++++++ // .... } 在kpagetable的页表中添加kernel stack的映射： 理解+思路：原本kernel stack的初始化是在启动时的procinit()里完成的。现在为了把它加进kpagetable的映射中，需要把整个初始化过程移动到创建kpagetable的地方——也就是allocproc()中。 实现： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 // kernel/proc.c 移动代码 // initialize the proc table at boot time. void procinit(void) { struct proc *p; initlock(\u0026pid_lock, \"nextpid\"); for(p = proc; p \u003c \u0026proc[NPROC]; p++) { initlock(\u0026p-\u003elock, \"proc\"); // ----- 这里注释/删除掉原本的kstack初始化 } kvminithart(); } static struct proc* allocproc(void) { // ++++++++上面删掉的代码移动到这里 // Allocate a page for the process's kernel stack. // Map it high in memory, followed by an invalid // guard page. char *pa = kalloc(); if(pa == 0) panic(\"kalloc\"); // get kstack va uint64 va = KSTACK((int)(p - proc)); // map kernal pagetable with kernal stack \u003c- 这里构建映射 uvmmap(p-\u003ekpagetable, va, (uint64)pa, PGSIZE, PTE_R | PTE_W); // 把va存在proc结构里 p-\u003ekstack = va; // ++++++++++ // Set up new context to start executing at forkret, // which returns to user space. memset(\u0026p-\u003econtext, 0, sizeof(p-\u003econtext)); p-\u003econtext.ra = (uint64)forkret; p-\u003econtext.sp = p-\u003ekstack + PGSIZE; return p; } 修改进程调度函数 scheduler() ： 理解：（1）在切换进程时，把对应的kpagetable加载到satp寄存器，并清除缓存[*否则会导致错误的mapping被留着继续用]（2）没有进程运行时用global kernel_pagetable 思路：参考kvminithart()函数，它实现了把global kernel pagetable加载到satp以及清除缓存。只要页表改成proc-\u003ekpagetable即可 实现： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // kernel/proc.c 修改调度函数 void scheduler(void) { // ... for(;;){ // Avoid deadlock by ensuring that devices can interrupt. intr_on(); int found = 0; // use kernel_pagetable when no process is running if(found==0){ kvminithart(); // ++++ 无进程时使用global kernel pt } for(p = proc; p \u003c \u0026proc[NPROC]; p++) { acquire(\u0026p-\u003elock); if(p-\u003estate == RUNNABLE) { // Switch to chosen process. It is the process's job // to release its lock and then reacquire it // before jumping back to us. p-\u003estate = RUNNING; c-\u003eproc = p; w_satp(MAKE_SATP(p-\u003ekpagetable)); // ++++++ sfence_vma(); // ++++++ // 在跳进进程之前，就要完成satp的切换 swtch(\u0026c-\u003econtext, \u0026p-\u003econtext); // ... } // ... } } 在freeproc()中增加释放kstack和kpagetable内存的操作 理解：要求清除kpagetable中的所有映射，但是不能动物理内存，否则会影响global kernel pagetable（毕竟它们的va直接映射到了同一物理内存上）；kstack是process-specific的，可以全部清除 思路：关于kpagetable，参考freewalk() 写一个函数，遍历三层pagetable，对有效pte进行递归释放；如果pagetable直接映射到了物理内存就不递归。至于kstack，直接调用已有方法uvmumap()就可以清除映射。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // kernel/proc.c 增加函数 //++++++ // Free a process's page table without // freeing the physical memory it refers to void proc_freepagetable_vonly(pagetable_t kpagetable) { // there are 2^9 = 512 PTEs in a page table. for(int i = 0; i \u003c 512; i++){ pte_t pte = kpagetable[i]; if(pte \u0026 PTE_V) kpagetable[i] = 0; // 只有当映射到了下一层页表时，才会继续递归 if((pte \u0026 PTE_V) \u0026\u0026 (pte \u0026 (PTE_R|PTE_W|PTE_X)) == 0){ // this PTE points to a lower-level page table. uint64 child = PTE2PA(pte); proc_freepagetable_vonly((pagetable_t)child); } } kfree((void*)kpagetable); } //++++++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // kernel/proc.c 对freeproc的改动如下 // free a proc structure and the data hanging from it, // including user pages. // p-\u003elock must be held. static void freeproc(struct proc *p) { // ... p-\u003ekilled = 0; p-\u003exstate = 0; // ++++ 以下新增 if(p-\u003ekstack){ // 第四个参数do_free设置为1 即为同时释放物理内存 uvmunmap(p-\u003ekpagetable, p-\u003ekstack, 1, 1); } p-\u003ekstack = 0; if(p-\u003ekpagetable) proc_freepagetable_vonly(p-\u003ekpagetable); p-\u003ekpagetable = 0; // +++++ 以上新增 p-\u003estate = UNUSED; } 彩蛋：修改kvmpa()函数 理解：似乎是初始化disk时需要调用kvmpa，但是这个函数中目前walk的是global kernel pagetable，需要改成proc的kpagetable。 实现： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // kernel/vm.c // translate a kernel virtual address to // a physical address. only needed for // addresses on the stack. // assumes va is page aligned. uint64 kvmpa(pagetable_t kpagetable, uint64 va) // 签名加了页表的参数 { uint64 off = va % PGSIZE; pte_t *pte; uint64 pa; pte = walk(kpagetable, va, 0); // 这里修改成kpagetable if(pte == 0) panic(\"kvmpa\"); if((*pte \u0026 PTE_V) == 0) panic(\"kvmpa\"); pa = PTE2PA(*pte); return pa+off; } 1 2 3 4 5 // 然后再跟着报错， // 把调用这个kvmpa的地方传入 myproc()-\u003ekpagetable // kernel/virtio_disk.c disk.desc[idx[0]].addr = (uint64) kvmpa(myproc()-\u003ekpagetable, (uint64) \u0026buf0); 其他注意：\n添加函数后注意在def.h中更新声明 可以修改kernel/vm.c and kernel/proc.c，但不要动测试相关的代码 debug比较累 3 结果 tesk全部ok\n4 问题 有两个我觉得比较tricky的地方 freeproc的实现，主要是要理解释放内存的范围，然后找/写对应的函数 hints里没有提到的kvmpa()函数。在完成所有hints后make qemu会出现panic：kvmpa的报错，这个函数的调用链不是特别清楚。 3.3 Simplify copyin/copyinstr 1 要求 用vmcopy.c中给出的新函数copyin_new和copyinstr_new简化原有的copyin和copyinstr。\n2 分析 涉及到的知识点：\nuser address space和kernel address space（xv6book, p.32-36） kernel data和user data的起始虚拟地址不同 它们和物理地址的映射关系（kernel space中部分是direct-mapped的） address space和pagetable的关系 地址空间是一个抽象概念，它表示了一个进程的虚拟地址的范围 页表是实际用于将这些虚拟地址映射到物理地址的数据结构 然后简单分析一下task：\n原先由于global kernel pt里没有记录每个进程的用户地址空间的mapping，所以copyin在接受user的虚拟地址后，需要在软件中walk页表把虚拟地址转换成物理，然后才能从物理地址拷贝指定大小的内存到目标位置。\n现在我们每个进程都有自己的kpagetable，所以只要把用户地址空间的mapping也记录进来就能一定程度上简化步骤。为此需要把进程用户地址空间里的pte拷贝到kpagetable里。\n为什么可以记录进来？这和user space和kernel space的分布有关。kernel启动后的最低地址在PLIC（0xC000000），而user是从0开始的，它们的虚拟地址范围不重合，所以可以直接把user space的mapping直接加到（kernel自己不用的）kernel space里。\n3 实现 主要新写一个函数，用来把user pagetable拷贝到kpagetable里。\n简化copyin 1 2 3 4 5 6 7 8 9 10 // kernel/vm.c 修改函数 // Copy from user to kernel. // Copy len bytes to dst from virtual address srcva in a given page table. // Return 0 on success, -1 on error. int copyin(pagetable_t pagetable, char *dst, uint64 srcva, uint64 len) { return copyin_new(pagetable, dst, srcva, len); // ++ } 写一个从uvm拷到kvm里的函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // kernel/vm.c 新增函数uvm2kvm // copy uvm to kvm from START to END, // return 0 if successfull and -1 otherwise int uvm2kvm(pagetable_t upgtbl, pagetable_t kpgtbl, uint64 start, uint64 end) { // pointers to user pte and kernel pte // as walk() returns pointers pte_t *upte, *kpte; // exception: exceed plic limit if(end \u003c start || PGROUNDUP(end) \u003e= PLIC) return -1; // walk through every pte for(uint64 va = PGROUNDUP(start); va \u003c end; va += PGSIZE){ // look up user pte if ((upte = walk(upgtbl, va, 0)) == 0) { panic(\"uvm2kvm: failed to find user pte\"); } // look up kernel pte if ((kpte = walk(kpgtbl, va, 1)) == 0) { panic(\"uvm2kvm: failed to create kernel pte\"); } // add mapping // and cancelling user accessibility meanwhile *kpte = *upte \u0026 (~PTE_U); // set the user flag to 0 (forbid user access) } return 0; } 修改所有可能会改动/初始化user mapping的函数，包括fork(), exec(), growproc(), userinit() 在改动后需重新把user pagetable拷贝进kpagetable\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 // kernel/proc.c 修改fork \u0026 growproc \u0026 userinit int fork(void) { // ... np-\u003esz = p-\u003esz; // copy user addr space into kernel space // 注意是从newprocess的pagetable拷 if ((uvm2kvm(np-\u003epagetable, np-\u003ekpagetable, 0, np-\u003esz)) \u003c 0){ freeproc(np); release(\u0026np-\u003elock); return -1; } np-\u003eparent = p; // ... } // Grow or shrink user memory by n bytes. // Return 0 on success, -1 on failure. int growproc(int n) { uint sz; struct proc *p = myproc(); sz = p-\u003esz; if(n \u003e 0){ if((sz = uvmalloc(p-\u003epagetable, sz, sz + n)) == 0) { return -1; } // ++++ mem grow了，重新map一次 if(uvm2kvm(p-\u003epagetable, p-\u003ekpagetable, p-\u003esz, sz) \u003c 0) { return -1; } } else if(n \u003c 0){ sz = uvmdealloc(p-\u003epagetable, sz, sz + n); // ++++ mem shrink了，只清除映射 不动物理内存 if (n \u003e= PGSIZE) { uvmunmap(p-\u003ekpagetable, PGROUNDUP(sz), n/PGSIZE, 0); } } p-\u003esz = sz; return 0; } void userinit(void) { // ... // allocate one user page and copy init's instructions // and data into it. uvminit(p-\u003epagetable, initcode, sizeof(initcode)); p-\u003esz = PGSIZE; // 在pagetable init完成之后 uvm2kvm(p-\u003epagetable, p-\u003ekpagetable, 0, p-\u003esz); // +++ // ... } 1 2 3 4 5 6 7 8 9 10 11 12 // kernel/exec.c 修改exec int exec(char *path, char **argv) { // ... // （位置在进程页表初始化完之后） // copy user pagetable to kernel if(uvm2kvm(pagetable, p-\u003ekpagetable, 0, sz) \u003c 0) goto bad; // ... } 确认copyin没问题了，相似方法修改copyinstr 1 2 3 4 5 6 7 // kernel/vm.c 修改函数copyinstr int copyinstr(pagetable_t pagetable, char *dst, uint64 srcva, uint64 max) { return copyinstr_new(pagetable, dst, srcva, max); // +++ } 4 结果 tests ok\nFINAL：tests\u0026grade 参考 https://clownote.github.io/2021/03/11/xv6/Xv6-Lab-page-tables/\nhttps://blog.csdn.net/LostUnravel/article/details/121340933\n",
  "wordCount" : "2008",
  "inLanguage": "en",
  "datePublished": "2023-09-25T18:43:10-04:00",
  "dateModified": "2023-09-25T18:43:10-04:00",
  "author":{
    "@type": "Person",
    "name": "fll"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://eimy.ink/en/posts/2023/xv6/lab-pgtbl/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "FloraZ",
    "logo": {
      "@type": "ImageObject",
      "url": "http://eimy.ink/favicons/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://eimy.ink/en/" accesskey="h" title="FloraZ (Alt + H)">FloraZ</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                    <li>
                        <a href="http://eimy.ink/" title="中文"
                            aria-label="中文">中文</a>
                    </li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://eimy.ink/en/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="http://eimy.ink/en/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="http://eimy.ink/en/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="http://eimy.ink/en/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="http://eimy.ink/en/about/" title="About">
                    <span>About</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main post">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://eimy.ink/en/">Home</a>&nbsp;»&nbsp;<a href="http://eimy.ink/en/posts/">Posts</a></div>
    <h1 class="post-title">
      xv6: Lab 3 pgtbl Notes
    </h1>
    <div class="post-meta"><span title='2023-09-25 18:43:10 -0400 EDT'>September 25, 2023</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;fll&nbsp;|&nbsp;Translations:
<ul class="i18n_list">
    <li>
        <a href="http://eimy.ink/posts/2023/xv6/lab-pgtbl/">中文</a>
    </li>
</ul>

</div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">Table of Contents</span>
            </summary>

            <div class="inner"><ul><ul>
                    <li>
                        <a href="#31-print-a-page-table" aria-label="3.1 Print a page table">3.1 Print a page table</a><ul>
                            
                    <li>
                        <a href="#1-%e5%85%b7%e4%bd%93%e8%a6%81%e6%b1%82" aria-label="1 具体要求">1 具体要求</a></li>
                    <li>
                        <a href="#2-%e5%ae%9e%e7%8e%b0%e6%96%b9%e6%b3%95" aria-label="2 实现方法">2 实现方法</a></li>
                    <li>
                        <a href="#3-%e7%bb%93%e6%9e%9c" aria-label="3 结果">3 结果</a></li>
                    <li>
                        <a href="#4-%e9%97%ae%e9%a2%98%e6%80%9d%e8%80%83" aria-label="4 问题&amp;amp;思考">4 问题&amp;思考</a></li></ul>
                    </li>
                    <li>
                        <a href="#32-a-kernel-page-table-per-process" aria-label="3.2 A kernel page table per process">3.2 A kernel page table per process</a><ul>
                            
                    <li>
                        <a href="#1-%e8%a6%81%e6%b1%82" aria-label="1 要求">1 要求</a></li>
                    <li>
                        <a href="#2-%e5%ae%9e%e7%8e%b0%e6%96%b9%e6%b3%95-1" aria-label="2 实现方法">2 实现方法</a></li>
                    <li>
                        <a href="#3-%e7%bb%93%e6%9e%9c-1" aria-label="3 结果">3 结果</a></li>
                    <li>
                        <a href="#4-%e9%97%ae%e9%a2%98" aria-label="4 问题">4 问题</a></li></ul>
                    </li>
                    <li>
                        <a href="#33-simplify-copyincopyinstr" aria-label="3.3 Simplify copyin/copyinstr">3.3 Simplify <code>copyin/copyinstr</code></a><ul>
                            
                    <li>
                        <a href="#1-%e8%a6%81%e6%b1%82-1" aria-label="1 要求">1 要求</a></li>
                    <li>
                        <a href="#2-%e5%88%86%e6%9e%90" aria-label="2 分析">2 分析</a></li>
                    <li>
                        <a href="#3-%e5%ae%9e%e7%8e%b0" aria-label="3 实现">3 实现</a></li>
                    <li>
                        <a href="#4-%e7%bb%93%e6%9e%9c" aria-label="4 结果">4 结果</a></li></ul>
                    </li>
                    <li>
                        <a href="#finaltestsgrade" aria-label="FINAL：tests&amp;amp;grade">FINAL：tests&amp;grade</a></li></ul>
                        
                    <li>
                        <a href="#%e5%8f%82%e8%80%83" aria-label="参考">参考</a>
                    </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>

  <div class="post-content"><blockquote>
<p>Translation WIP: written in Chinese.</p>
</blockquote>
<p>Lab url：https://pdos.csail.mit.edu/6.828/2020/labs/pgtbl.html</p>
<p>course site：https://pdos.csail.mit.edu/6.828/2020/schedule.html</p>
<p>gdb usage：https://pdos.csail.mit.edu/6.1810/2022/labs/gdb.html</p>
<h3 id="31-print-a-page-table">3.1 Print a page table<a hidden class="anchor" aria-hidden="true" href="#31-print-a-page-table">#</a></h3>
<h4 id="1-具体要求">1 具体要求<a hidden class="anchor" aria-hidden="true" href="#1-具体要求">#</a></h4>
<p>要求实现一个<code>vmprint()</code>函数，接受一个pagetable参数，按照要求的格式打印出这个pagetable。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="c1"># Print Format:</span>
</span></span><span class="line"><span class="cl"><span class="c1"># page table [argument]</span>
</span></span><span class="line"><span class="cl">page table 0x0000000087f6e000
</span></span><span class="line"><span class="cl"><span class="c1"># [depth] [pte index]: [pagetable entry] pa [physical address]</span>
</span></span><span class="line"><span class="cl">..0: pte 0x0000000021fda801 pa 0x0000000087f6a000
</span></span><span class="line"><span class="cl">.. ..0: pte 0x0000000021fda401 pa 0x0000000087f69000
</span></span><span class="line"><span class="cl">.. .. ..0: pte 0x0000000021fdac1f pa 0x0000000087f6b000
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="2-实现方法">2 实现方法<a hidden class="anchor" aria-hidden="true" href="#2-实现方法">#</a></h4>
<p>这个task相关的知识点：</p>
<ul>
<li>VA, PA, PPN, PTE的构成、作用和它们之间的关系，比如
<ul>
<li>虚拟地址（VA）中包括27bits，其中每9bits对应一个page table entry（PTE）</li>
<li>VA包含几个部分，其中27位（3*9）用于在各层页表中索引PTE，另有12位offset用来在PA中索引定位</li>
<li>页表PTE中的PPN用来寻找下一层页表</li>
</ul>
</li>
<li>xv6页表的three-level tree结构 (xv6book, p.30-1)：
<ul>
<li>VA-PA转换的逻辑是：最上层页表的地址是由satp寄存器记录的；通过va中27bits里最左的9bits索引，查找到最上层的页表中对应的PTE；然后通过这个PTE中的PPN找到第二个页表，由VA中第二个9bits索引到对应的PTE，以此类推&hellip;最后再结合VA中的offset定位PA</li>
<li>VA-PA translation是由硬件memory management unit（MMU）实现的（如果没听错，lec里说软件也可以，但是硬件更快）</li>
</ul>
</li>
<li>如何判断PPN映射到了下一层页表还是物理内存？
<ul>
<li>参考<code>freewalk()</code>，如果<code>(pte &amp; (PTE_R|PTE_W|PTE_X)) == 0</code>，即不可读/写/执行，就说明PPN没有映射到物理内存，而是映射到了更低层的页表</li>
</ul>
</li>
</ul>
<p>有三层pagetable，我选择了递归打印。这个task标了easy难度，跟着hints就能实现。代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// helper function for vmprint
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span>
</span></span><span class="line"><span class="cl"><span class="nf">printhelper</span><span class="p">(</span><span class="kt">pagetable_t</span> <span class="n">pagetable</span><span class="p">,</span> <span class="kt">int</span> <span class="n">depth</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// there are 2^9 = 512 PTEs in a page table.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">512</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">pte_t</span> <span class="n">pte</span> <span class="o">=</span> <span class="n">pagetable</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// skip invalid pages
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">pte</span> <span class="o">&amp;</span> <span class="n">PTE_V</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// print indentation
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">depth</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;..&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">depth</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34; &#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%d: pte %p pa %p</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="nf">PTE2PA</span><span class="p">(</span><span class="n">pte</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">      
</span></span><span class="line"><span class="cl">  	<span class="c1">// has lower-level pt -&gt; recursive call on child
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span><span class="p">((</span><span class="n">pte</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PTE_R</span><span class="o">|</span><span class="n">PTE_W</span><span class="o">|</span><span class="n">PTE_X</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="n">uint64</span> <span class="n">child</span> <span class="o">=</span> <span class="nf">PTE2PA</span><span class="p">(</span><span class="n">pte</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="nf">printhelper</span><span class="p">((</span><span class="kt">pagetable_t</span><span class="p">)</span><span class="n">child</span><span class="p">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// print the content of a page table
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span>
</span></span><span class="line"><span class="cl"><span class="nf">vmprint</span><span class="p">(</span><span class="kt">pagetable_t</span> <span class="n">pagetable</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// refer to freewalk()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;page table %p</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">pagetable</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">printhelper</span><span class="p">(</span><span class="n">pagetable</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="3-结果">3 结果<a hidden class="anchor" aria-hidden="true" href="#3-结果">#</a></h4>
<p>和要求print内容一致，test ok。</p>
<h4 id="4-问题思考">4 问题&amp;思考<a hidden class="anchor" aria-hidden="true" href="#4-问题思考">#</a></h4>
<p>最后有个challenge question问打印出来的page0、page1、page2里是什么。</p>
<p>因为vmprint是在<code>kernel/exec.c</code>中调用的，所以回去看<code>kernel/exec.c</code>里有分配页表的地方，源码上面有注释：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 分配了1 page
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Load program into memory. 那这个页表应该是data+text
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">if</span><span class="p">((</span><span class="n">sz1</span> <span class="o">=</span> <span class="nf">uvmalloc</span><span class="p">(</span><span class="n">pagetable</span><span class="p">,</span> <span class="n">sz</span><span class="p">,</span> <span class="n">ph</span><span class="p">.</span><span class="n">vaddr</span> <span class="o">+</span> <span class="n">ph</span><span class="p">.</span><span class="n">memsz</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 分配了2 pages
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Allocate two pages at the next page boundary.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Use the second as the user stack.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">if</span><span class="p">((</span><span class="n">sz1</span> <span class="o">=</span> <span class="nf">uvmalloc</span><span class="p">(</span><span class="n">pagetable</span><span class="p">,</span> <span class="n">sz</span><span class="p">,</span> <span class="n">sz</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">PGSIZE</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>所以根据Figure3.4，这些应该是init user stack时分配的，page0是data+text，page1是guard page（PTE_V not set, 不可read/write），page2是顶上的stack。</p>
<h3 id="32-a-kernel-page-table-per-process">3.2 A kernel page table per process<a hidden class="anchor" aria-hidden="true" href="#32-a-kernel-page-table-per-process">#</a></h3>
<h4 id="1-要求">1 要求<a hidden class="anchor" aria-hidden="true" href="#1-要求">#</a></h4>
<p>让每个进程都有一个自己的kernel pagetable，它们的页表和global kernel page保持一致。在切换进程时，也要切换到该进程对应的kernel pagetable（无进程运行时用global kernel pagetable。</p>
<p>和当前task相关的知识点：</p>
<ul>
<li>每个进程维护一个页表的用户地址空间和一个页表的内核地址空间：&ldquo;Xv6 maintains one page table per process, describing each process’s user address space, plus a single page table that describes the kernel’s address space.&rdquo; (xv6book, p.31)</li>
<li>Figure 3.3 内核地址空间里的映射关系（明白这点才知道之后如何构建kernel pagetable的mapping），里面哪些是直接映射、哪些不是（和后面的kstack有关）。</li>
<li>以及上面的页表结构，还会再次用到</li>
</ul>
<h4 id="2-实现方法-1">2 实现方法<a hidden class="anchor" aria-hidden="true" href="#2-实现方法-1">#</a></h4>
<p>和hints给的顺序基本一致：</p>
<ul>
<li>声明kernel pagetable变量：在 <code>struct proc</code> 中增加变量<code>pagetable_t kpagetable</code>，由此每个process都有了自己的kpt</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// kernel/proc.h 结构体里增加一个变量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">proc</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ... private
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">pagetable_t</span> <span class="n">kpagetable</span><span class="p">;</span>      <span class="c1">// (+) Kernel page table
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>仿照<code>kvminit</code> 写一个函数，用来创建kpagetable页表并构建映射：
<ul>
<li>理解：要在分配进程（即<code>allocproc()</code>里）时，增加「给kpagetable分配内存」 -&gt; 「直接映射到和global kernel pagetable相同物理地址」这些构建操作</li>
<li>思路：这些功能在<code>kvminit</code>中已有类似实现，但是不能直接调用<code>kvminit</code>，因为它调用了<code>kvmmap()</code>，后者是用<code>mappages</code> direct map了<u>global kernel page</u>和对应的pa。这里是要map<u>各个进程的kernel page</u>和pa，所以需要另写一个和<code>kvmmap</code>类似、但是允许传入指定pagetable的函数，然后在构建kpagetable时调用。</li>
<li>实现：</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// kernel/vm.c 实现一个类似kvmmap的函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// +++++++以下都是新增的
</span></span></span><span class="line"><span class="cl"><span class="c1">// add a mapping to a given page table
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span>
</span></span><span class="line"><span class="cl"><span class="nf">uvmmap</span><span class="p">(</span><span class="kt">pagetable_t</span> <span class="n">pt</span><span class="p">,</span> <span class="n">uint64</span> <span class="n">va</span><span class="p">,</span> <span class="n">uint64</span> <span class="n">pa</span><span class="p">,</span> <span class="n">uint64</span> <span class="n">sz</span><span class="p">,</span> <span class="kt">int</span> <span class="n">perm</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span><span class="nf">mappages</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">va</span><span class="p">,</span> <span class="n">sz</span><span class="p">,</span> <span class="n">pa</span><span class="p">,</span> <span class="n">perm</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">panic</span><span class="p">(</span><span class="s">&#34;uvmmap&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 参考了kvminit,
</span></span></span><span class="line"><span class="cl"><span class="c1">// 把kvmmap换成了上面的uvm以自定义需要map的pagetable
</span></span></span><span class="line"><span class="cl"><span class="c1">// Create a kernel page table for a given process
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">pagetable_t</span>
</span></span><span class="line"><span class="cl"><span class="nf">proc_kpagetable</span><span class="p">(</span><span class="k">struct</span> <span class="n">proc</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">pagetable_t</span> <span class="n">kpagetable</span> <span class="o">=</span> <span class="p">(</span><span class="kt">pagetable_t</span><span class="p">)</span> <span class="nf">kalloc</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="nf">memset</span><span class="p">(</span><span class="n">kpagetable</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PGSIZE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// uart registers
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">uvmmap</span><span class="p">(</span><span class="n">kpagetable</span><span class="p">,</span> <span class="n">UART0</span><span class="p">,</span> <span class="n">UART0</span><span class="p">,</span> <span class="n">PGSIZE</span><span class="p">,</span> <span class="n">PTE_R</span> <span class="o">|</span> <span class="n">PTE_W</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// virtio mmio disk interface
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">uvmmap</span><span class="p">(</span><span class="n">kpagetable</span><span class="p">,</span> <span class="n">VIRTIO0</span><span class="p">,</span> <span class="n">VIRTIO0</span><span class="p">,</span> <span class="n">PGSIZE</span><span class="p">,</span> <span class="n">PTE_R</span> <span class="o">|</span> <span class="n">PTE_W</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// CLINT
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">uvmmap</span><span class="p">(</span><span class="n">kpagetable</span><span class="p">,</span> <span class="n">CLINT</span><span class="p">,</span> <span class="n">CLINT</span><span class="p">,</span> <span class="mh">0x10000</span><span class="p">,</span> <span class="n">PTE_R</span> <span class="o">|</span> <span class="n">PTE_W</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// PLIC
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">uvmmap</span><span class="p">(</span><span class="n">kpagetable</span><span class="p">,</span> <span class="n">PLIC</span><span class="p">,</span> <span class="n">PLIC</span><span class="p">,</span> <span class="mh">0x400000</span><span class="p">,</span> <span class="n">PTE_R</span> <span class="o">|</span> <span class="n">PTE_W</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// map kernel text executable and read-only.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">uvmmap</span><span class="p">(</span><span class="n">kpagetable</span><span class="p">,</span> <span class="n">KERNBASE</span><span class="p">,</span> <span class="n">KERNBASE</span><span class="p">,</span> <span class="p">(</span><span class="n">uint64</span><span class="p">)</span><span class="n">etext</span><span class="o">-</span><span class="n">KERNBASE</span><span class="p">,</span> <span class="n">PTE_R</span> <span class="o">|</span> <span class="n">PTE_X</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// map kernel data and the physical RAM we&#39;ll make use of.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">uvmmap</span><span class="p">(</span><span class="n">kpagetable</span><span class="p">,</span> <span class="p">(</span><span class="n">uint64</span><span class="p">)</span><span class="n">etext</span><span class="p">,</span> <span class="p">(</span><span class="n">uint64</span><span class="p">)</span><span class="n">etext</span><span class="p">,</span> <span class="n">PHYSTOP</span><span class="o">-</span><span class="p">(</span><span class="n">uint64</span><span class="p">)</span><span class="n">etext</span><span class="p">,</span> <span class="n">PTE_R</span> <span class="o">|</span> <span class="n">PTE_W</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// map the trampoline for trap entry/exit to
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// the highest virtual address in the kernel.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">uvmmap</span><span class="p">(</span><span class="n">kpagetable</span><span class="p">,</span> <span class="n">TRAMPOLINE</span><span class="p">,</span> <span class="p">(</span><span class="n">uint64</span><span class="p">)</span><span class="n">trampoline</span><span class="p">,</span> <span class="n">PGSIZE</span><span class="p">,</span> <span class="n">PTE_R</span> <span class="o">|</span> <span class="n">PTE_X</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">kpagetable</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// +++++++
</span></span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// kernel/proc.c 新增代码片段
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// Look in the process table for an UNUSED proc.
</span></span></span><span class="line"><span class="cl"><span class="c1">// If found, initialize state required to run in the kernel,
</span></span></span><span class="line"><span class="cl"><span class="c1">// and return with p-&gt;lock held.
</span></span></span><span class="line"><span class="cl"><span class="c1">// If there are no free procs, or a memory allocation fails, return 0.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">static</span> <span class="k">struct</span> <span class="n">proc</span><span class="o">*</span>
</span></span><span class="line"><span class="cl"><span class="nf">allocproc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ....
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// An empty user page table.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">p</span><span class="o">-&gt;</span><span class="n">pagetable</span> <span class="o">=</span> <span class="nf">proc_pagetable</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pagetable</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="nf">freeproc</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">  <span class="c1">// +++++++++++
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// Create a kernel page table.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">p</span><span class="o">-&gt;</span><span class="n">kpagetable</span> <span class="o">=</span> <span class="nf">proc_kpagetable</span><span class="p">(</span><span class="n">p</span><span class="p">);</span> <span class="c1">// 在这里调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">kpagetable</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="nf">freeproc</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// +++++++++++
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// ....
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>在kpagetable的页表中添加kernel stack的映射：
<ul>
<li>理解+思路：原本kernel stack的初始化是在启动时的<code>procinit()</code>里完成的。现在为了把它加进kpagetable的映射中，需要把整个初始化过程移动到创建kpagetable的地方——也就是<code>allocproc()</code>中。</li>
<li>实现：</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// kernel/proc.c 移动代码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// initialize the proc table at boot time.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span>
</span></span><span class="line"><span class="cl"><span class="nf">procinit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">proc</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="nf">initlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pid_lock</span><span class="p">,</span> <span class="s">&#34;nextpid&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span><span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">proc</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="o">&amp;</span><span class="n">proc</span><span class="p">[</span><span class="n">NPROC</span><span class="p">];</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nf">initlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="s">&#34;proc&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	  <span class="c1">// ----- 这里注释/删除掉原本的kstack初始化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="nf">kvminithart</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="k">struct</span> <span class="n">proc</span><span class="o">*</span>
</span></span><span class="line"><span class="cl"><span class="nf">allocproc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ++++++++上面删掉的代码移动到这里
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// Allocate a page for the process&#39;s kernel stack.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// Map it high in memory, followed by an invalid
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// guard page.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">char</span> <span class="o">*</span><span class="n">pa</span> <span class="o">=</span> <span class="nf">kalloc</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span><span class="n">pa</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">panic</span><span class="p">(</span><span class="s">&#34;kalloc&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// get kstack va
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">uint64</span> <span class="n">va</span> <span class="o">=</span> <span class="nf">KSTACK</span><span class="p">((</span><span class="kt">int</span><span class="p">)(</span><span class="n">p</span> <span class="o">-</span> <span class="n">proc</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// map kernal pagetable with kernal stack &lt;- 这里构建映射
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">uvmmap</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">kpagetable</span><span class="p">,</span> <span class="n">va</span><span class="p">,</span> <span class="p">(</span><span class="n">uint64</span><span class="p">)</span><span class="n">pa</span><span class="p">,</span> <span class="n">PGSIZE</span><span class="p">,</span> <span class="n">PTE_R</span> <span class="o">|</span> <span class="n">PTE_W</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 把va存在proc结构里
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">p</span><span class="o">-&gt;</span><span class="n">kstack</span> <span class="o">=</span> <span class="n">va</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ++++++++++
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Set up new context to start executing at forkret,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// which returns to user space.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="n">p</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">.</span><span class="n">ra</span> <span class="o">=</span> <span class="p">(</span><span class="n">uint64</span><span class="p">)</span><span class="n">forkret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">p</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">.</span><span class="n">sp</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">kstack</span> <span class="o">+</span> <span class="n">PGSIZE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>修改进程调度函数 <code>scheduler()</code> ：
<ul>
<li>理解：（1）在切换进程时，把对应的kpagetable加载到satp寄存器，并清除缓存[*否则会导致错误的mapping被留着继续用]（2）没有进程运行时用global  <code>kernel_pagetable</code></li>
<li>思路：参考<code>kvminithart()</code>函数，它实现了把global kernel pagetable加载到satp以及清除缓存。只要页表改成<code>proc-&gt;kpagetable</code>即可</li>
<li>实现：</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// kernel/proc.c 修改调度函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span>
</span></span><span class="line"><span class="cl"><span class="nf">scheduler</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">for</span><span class="p">(;;){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Avoid deadlock by ensuring that devices can interrupt.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">intr_on</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// use kernel_pagetable when no process is running
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">found</span><span class="o">==</span><span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="nf">kvminithart</span><span class="p">();</span> <span class="c1">// ++++ 无进程时使用global kernel pt
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">proc</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="o">&amp;</span><span class="n">proc</span><span class="p">[</span><span class="n">NPROC</span><span class="p">];</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nf">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">RUNNABLE</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Switch to chosen process.  It is the process&#39;s job
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// to release its lock and then reacquire it
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// before jumping back to us.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">RUNNING</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">c</span><span class="o">-&gt;</span><span class="n">proc</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nf">w_satp</span><span class="p">(</span><span class="nf">MAKE_SATP</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">kpagetable</span><span class="p">));</span>  <span class="c1">// ++++++
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">sfence_vma</span><span class="p">();</span> 			    	   <span class="c1">// ++++++
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 在跳进进程之前，就要完成satp的切换
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">swtch</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>在<code>freeproc()</code>中增加释放kstack和kpagetable内存的操作
<ul>
<li>理解：要求清除kpagetable中的所有映射，但是不能动物理内存，否则会影响global kernel pagetable（毕竟它们的va直接映射到了同一物理内存上）；kstack是process-specific的，可以全部清除</li>
<li>思路：关于kpagetable，参考<code>freewalk() </code>写一个函数，遍历三层pagetable，对有效pte进行递归释放；如果pagetable直接映射到了物理内存就不递归。至于kstack，直接调用已有方法<code>uvmumap()</code>就可以清除映射。</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// kernel/proc.c 增加函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">//++++++
</span></span></span><span class="line"><span class="cl"><span class="c1">// Free a process&#39;s page table without
</span></span></span><span class="line"><span class="cl"><span class="c1">// freeing the physical memory it refers to
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span>
</span></span><span class="line"><span class="cl"><span class="nf">proc_freepagetable_vonly</span><span class="p">(</span><span class="kt">pagetable_t</span> <span class="n">kpagetable</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// there are 2^9 = 512 PTEs in a page table.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">512</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">pte_t</span> <span class="n">pte</span> <span class="o">=</span> <span class="n">kpagetable</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">pte</span> <span class="o">&amp;</span> <span class="n">PTE_V</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">      <span class="n">kpagetable</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 只有当映射到了下一层页表时，才会继续递归
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span><span class="p">((</span><span class="n">pte</span> <span class="o">&amp;</span> <span class="n">PTE_V</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">pte</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PTE_R</span><span class="o">|</span><span class="n">PTE_W</span><span class="o">|</span><span class="n">PTE_X</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// this PTE points to a lower-level page table.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">uint64</span> <span class="n">child</span> <span class="o">=</span> <span class="nf">PTE2PA</span><span class="p">(</span><span class="n">pte</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="nf">proc_freepagetable_vonly</span><span class="p">((</span><span class="kt">pagetable_t</span><span class="p">)</span><span class="n">child</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="nf">kfree</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">kpagetable</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">//++++++
</span></span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// kernel/proc.c 对freeproc的改动如下
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// free a proc structure and the data hanging from it,
</span></span></span><span class="line"><span class="cl"><span class="c1">// including user pages.
</span></span></span><span class="line"><span class="cl"><span class="c1">// p-&gt;lock must be held.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">static</span> <span class="kt">void</span>
</span></span><span class="line"><span class="cl"><span class="nf">freeproc</span><span class="p">(</span><span class="k">struct</span> <span class="n">proc</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">p</span><span class="o">-&gt;</span><span class="n">killed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">p</span><span class="o">-&gt;</span><span class="n">xstate</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ++++ 以下新增
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">kstack</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 第四个参数do_free设置为1 即为同时释放物理内存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">uvmunmap</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">kpagetable</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">kstack</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">p</span><span class="o">-&gt;</span><span class="n">kstack</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">kpagetable</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">proc_freepagetable_vonly</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">kpagetable</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">p</span><span class="o">-&gt;</span><span class="n">kpagetable</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// +++++ 以上新增
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">UNUSED</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>彩蛋：修改<code>kvmpa()</code>函数
<ul>
<li>理解：似乎是初始化disk时需要调用kvmpa，但是这个函数中目前<code>walk</code>的是global kernel pagetable，需要改成proc的kpagetable。</li>
<li>实现：</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// kernel/vm.c
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// translate a kernel virtual address to
</span></span></span><span class="line"><span class="cl"><span class="c1">// a physical address. only needed for
</span></span></span><span class="line"><span class="cl"><span class="c1">// addresses on the stack.
</span></span></span><span class="line"><span class="cl"><span class="c1">// assumes va is page aligned.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">uint64</span>
</span></span><span class="line"><span class="cl"><span class="nf">kvmpa</span><span class="p">(</span><span class="kt">pagetable_t</span> <span class="n">kpagetable</span><span class="p">,</span> <span class="n">uint64</span> <span class="n">va</span><span class="p">)</span> <span class="c1">// 签名加了页表的参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">uint64</span> <span class="n">off</span> <span class="o">=</span> <span class="n">va</span> <span class="o">%</span> <span class="n">PGSIZE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">pte_t</span> <span class="o">*</span><span class="n">pte</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">uint64</span> <span class="n">pa</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="n">pte</span> <span class="o">=</span> <span class="nf">walk</span><span class="p">(</span><span class="n">kpagetable</span><span class="p">,</span> <span class="n">va</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// 这里修改成kpagetable
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span><span class="p">(</span><span class="n">pte</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">panic</span><span class="p">(</span><span class="s">&#34;kvmpa&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">((</span><span class="o">*</span><span class="n">pte</span> <span class="o">&amp;</span> <span class="n">PTE_V</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">panic</span><span class="p">(</span><span class="s">&#34;kvmpa&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">pa</span> <span class="o">=</span> <span class="nf">PTE2PA</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">pa</span><span class="o">+</span><span class="n">off</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// 然后再跟着报错，
</span></span></span><span class="line"><span class="cl"><span class="c1">// 把调用这个kvmpa的地方传入 myproc()-&gt;kpagetable
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// kernel/virtio_disk.c
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">disk</span><span class="p">.</span><span class="n">desc</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]].</span><span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">uint64</span><span class="p">)</span> <span class="nf">kvmpa</span><span class="p">(</span><span class="nf">myproc</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">kpagetable</span><span class="p">,</span> <span class="p">(</span><span class="n">uint64</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">buf0</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>其他注意：</p>
<ul>
<li>添加函数后注意在def.h中更新声明</li>
<li>可以修改<code>kernel/vm.c</code> and <code>kernel/proc.c</code>，但不要动测试相关的代码</li>
<li>debug比较累</li>
</ul>
<h4 id="3-结果-1">3 结果<a hidden class="anchor" aria-hidden="true" href="#3-结果-1">#</a></h4>
<p>tesk全部ok</p>
<h4 id="4-问题">4 问题<a hidden class="anchor" aria-hidden="true" href="#4-问题">#</a></h4>
<ul>
<li>有两个我觉得比较tricky的地方
<ul>
<li>freeproc的实现，主要是要理解释放内存的范围，然后找/写对应的函数</li>
<li>hints里没有提到的<code>kvmpa()</code>函数。在完成所有hints后make qemu会出现panic：kvmpa的报错，这个函数的调用链不是特别清楚。</li>
</ul>
</li>
</ul>
<h3 id="33-simplify-copyincopyinstr">3.3 Simplify <code>copyin/copyinstr</code><a hidden class="anchor" aria-hidden="true" href="#33-simplify-copyincopyinstr">#</a></h3>
<h4 id="1-要求-1">1 要求<a hidden class="anchor" aria-hidden="true" href="#1-要求-1">#</a></h4>
<p>用<code>vmcopy.c</code>中给出的新函数<code>copyin_new</code>和<code>copyinstr_new</code>简化原有的<code>copyin</code>和<code>copyinstr</code>。</p>
<h4 id="2-分析">2 分析<a hidden class="anchor" aria-hidden="true" href="#2-分析">#</a></h4>
<p>涉及到的知识点：</p>
<ul>
<li>user address space和kernel address space（xv6book, p.32-36）
<ul>
<li>kernel data和user data的起始虚拟地址不同</li>
<li>它们和物理地址的映射关系（kernel space中部分是direct-mapped的）</li>
</ul>
</li>
<li>address space和pagetable的关系
<ul>
<li>地址空间是一个抽象概念，它表示了一个进程的虚拟地址的范围</li>
<li>页表是实际用于将这些虚拟地址映射到物理地址的数据结构</li>
</ul>
</li>
</ul>
<p>然后简单分析一下task：</p>
<p>原先由于global kernel pt里没有记录每个进程的用户地址空间的mapping，所以copyin在接受user的虚拟地址后，需要在软件中<code>walk</code>页表把虚拟地址转换成物理，然后才能从物理地址拷贝指定大小的内存到目标位置。</p>
<p>现在我们每个进程都有自己的<code>kpagetable</code>，所以只要把用户地址空间的mapping也记录进来就能一定程度上简化步骤。为此需要把进程用户地址空间里的pte拷贝到<code>kpagetable</code>里。</p>
<p>为什么可以记录进来？这和user space和kernel space的分布有关。kernel启动后的最低地址在PLIC（<code>0xC000000</code>），而user是从0开始的，它们的虚拟地址范围不重合，所以可以直接把user space的mapping直接加到（kernel自己不用的）kernel space里。</p>
<h4 id="3-实现">3 实现<a hidden class="anchor" aria-hidden="true" href="#3-实现">#</a></h4>
<p>主要新写一个函数，用来把user pagetable拷贝到kpagetable里。</p>
<ul>
<li>简化copyin</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// kernel/vm.c 修改函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// Copy from user to kernel.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Copy len bytes to dst from virtual address srcva in a given page table.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Return 0 on success, -1 on error.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="nf">copyin</span><span class="p">(</span><span class="kt">pagetable_t</span> <span class="n">pagetable</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="n">uint64</span> <span class="n">srcva</span><span class="p">,</span> <span class="n">uint64</span> <span class="n">len</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">return</span> <span class="nf">copyin_new</span><span class="p">(</span><span class="n">pagetable</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">srcva</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span> <span class="c1">// ++
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>写一个从uvm拷到kvm里的函数</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// kernel/vm.c 新增函数uvm2kvm
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// copy uvm to kvm from START to END,
</span></span></span><span class="line"><span class="cl"><span class="c1">// return 0 if successfull and -1 otherwise
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="nf">uvm2kvm</span><span class="p">(</span><span class="kt">pagetable_t</span> <span class="n">upgtbl</span><span class="p">,</span> <span class="kt">pagetable_t</span> <span class="n">kpgtbl</span><span class="p">,</span> <span class="n">uint64</span> <span class="n">start</span><span class="p">,</span> <span class="n">uint64</span> <span class="n">end</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// pointers to user pte and kernel pte
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// as walk() returns pointers
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">pte_t</span> <span class="o">*</span><span class="n">upte</span><span class="p">,</span> <span class="o">*</span><span class="n">kpte</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// exception: exceed plic limit
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span><span class="p">(</span><span class="n">end</span> <span class="o">&lt;</span> <span class="n">start</span> <span class="o">||</span> <span class="nf">PGROUNDUP</span><span class="p">(</span><span class="n">end</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">PLIC</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// walk through every pte
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">for</span><span class="p">(</span><span class="n">uint64</span> <span class="n">va</span> <span class="o">=</span> <span class="nf">PGROUNDUP</span><span class="p">(</span><span class="n">start</span><span class="p">);</span> <span class="n">va</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="n">va</span> <span class="o">+=</span> <span class="n">PGSIZE</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// look up user pte
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">((</span><span class="n">upte</span> <span class="o">=</span> <span class="nf">walk</span><span class="p">(</span><span class="n">upgtbl</span><span class="p">,</span> <span class="n">va</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nf">panic</span><span class="p">(</span><span class="s">&#34;uvm2kvm: failed to find user pte&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// look up kernel pte
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">((</span><span class="n">kpte</span> <span class="o">=</span> <span class="nf">walk</span><span class="p">(</span><span class="n">kpgtbl</span><span class="p">,</span> <span class="n">va</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nf">panic</span><span class="p">(</span><span class="s">&#34;uvm2kvm: failed to create kernel pte&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// add mapping
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// and cancelling user accessibility meanwhile
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">*</span><span class="n">kpte</span> <span class="o">=</span> <span class="o">*</span><span class="n">upte</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">PTE_U</span><span class="p">);</span> <span class="c1">// set the user flag to 0 (forbid user access)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>修改所有可能会改动/初始化user mapping的函数，包括<code>fork()</code>, <code>exec()</code>, <code>growproc()</code>, <code>userinit()</code></li>
</ul>
<p>在改动后需重新把user pagetable拷贝进kpagetable</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// kernel/proc.c 修改fork &amp; growproc &amp; userinit
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="nf">fork</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">np</span><span class="o">-&gt;</span><span class="n">sz</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">sz</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// copy user addr space into kernel space
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 注意是从newprocess的pagetable拷
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">((</span><span class="nf">uvm2kvm</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">pagetable</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">kpagetable</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">sz</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="nf">freeproc</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">np</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Grow or shrink user memory by n bytes.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Return 0 on success, -1 on failure.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="nf">growproc</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">uint</span> <span class="n">sz</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">proc</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="nf">myproc</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">sz</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">sz</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">((</span><span class="n">sz</span> <span class="o">=</span> <span class="nf">uvmalloc</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pagetable</span><span class="p">,</span> <span class="n">sz</span><span class="p">,</span> <span class="n">sz</span> <span class="o">+</span> <span class="n">n</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ++++ mem grow了，重新map一次
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="nf">uvm2kvm</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pagetable</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">kpagetable</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">sz</span><span class="p">,</span> <span class="n">sz</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">sz</span> <span class="o">=</span> <span class="nf">uvmdealloc</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pagetable</span><span class="p">,</span> <span class="n">sz</span><span class="p">,</span> <span class="n">sz</span> <span class="o">+</span> <span class="n">n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ++++ mem shrink了，只清除映射 不动物理内存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  	<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="n">PGSIZE</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  		<span class="nf">uvmunmap</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">kpagetable</span><span class="p">,</span> <span class="nf">PGROUNDUP</span><span class="p">(</span><span class="n">sz</span><span class="p">),</span> <span class="n">n</span><span class="o">/</span><span class="n">PGSIZE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="n">p</span><span class="o">-&gt;</span><span class="n">sz</span> <span class="o">=</span> <span class="n">sz</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span>
</span></span><span class="line"><span class="cl"><span class="nf">userinit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// allocate one user page and copy init&#39;s instructions
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// and data into it.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">uvminit</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pagetable</span><span class="p">,</span> <span class="n">initcode</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">initcode</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="n">p</span><span class="o">-&gt;</span><span class="n">sz</span> <span class="o">=</span> <span class="n">PGSIZE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 在pagetable init完成之后
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">uvm2kvm</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pagetable</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">kpagetable</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">sz</span><span class="p">);</span> <span class="c1">// +++
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// kernel/exec.c 修改exec
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="nf">exec</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// （位置在进程页表初始化完之后）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// copy user pagetable to kernel
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span><span class="p">(</span><span class="nf">uvm2kvm</span><span class="p">(</span><span class="n">pagetable</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">kpagetable</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sz</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>确认copyin没问题了，相似方法修改copyinstr</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// kernel/vm.c 修改函数copyinstr
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="nf">copyinstr</span><span class="p">(</span><span class="kt">pagetable_t</span> <span class="n">pagetable</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="n">uint64</span> <span class="n">srcva</span><span class="p">,</span> <span class="n">uint64</span> <span class="n">max</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nf">copyinstr_new</span><span class="p">(</span><span class="n">pagetable</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">srcva</span><span class="p">,</span> <span class="n">max</span><span class="p">);</span> <span class="c1">// +++
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="4-结果">4 结果<a hidden class="anchor" aria-hidden="true" href="#4-结果">#</a></h4>
<p>tests ok</p>
<h3 id="finaltestsgrade">FINAL：tests&amp;grade<a hidden class="anchor" aria-hidden="true" href="#finaltestsgrade">#</a></h3>
<p><img loading="lazy" src="./assets/image-20230923101708561.png" alt="image-20230923101708561"  />
</p>
<h2 id="参考">参考<a hidden class="anchor" aria-hidden="true" href="#参考">#</a></h2>
<p><a href="https://clownote.github.io/2021/03/11/xv6/Xv6-Lab-page-tables/">https://clownote.github.io/2021/03/11/xv6/Xv6-Lab-page-tables/</a></p>
<p><a href="https://blog.csdn.net/LostUnravel/article/details/121340933">https://blog.csdn.net/LostUnravel/article/details/121340933</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://eimy.ink/en/tags/operating-system/">Operating System</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="http://eimy.ink/en/posts/2023/xv6/lab-traps/">
    <span class="title">« Prev</span>
    <br>
    <span>xv6: Lab 4 traps Notes</span>
  </a>
  <a class="next" href="http://eimy.ink/en/posts/2023/cs61c/">
    <span class="title">Next »</span>
    <br>
    <span>CS61C Completed</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="http://eimy.ink/en/">FloraZ</a></span><span style="display: inline-block; margin-left: 1em;">
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/reorx/hugo-PaperMod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
  (function() {
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    const disableSmoothScroll = '' == '1';
    const enableInstantClick = '' == '1';
    
    if (window.matchMedia('(prefers-reduced-motion: reduce)').matches || disableSmoothScroll || enableInstantClick) {
      return;
    }
    
    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                behavior: "smooth"
            });
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });
  })();
</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = 'copy';

        function copyingDone() {
            copybutton.innerText = 'copied!';
            setTimeout(() => {
                copybutton.innerText = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
<script>
window.addEventListener('DOMContentLoaded', function (event) {
  const headings = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id]');
  const activeClass = 'active';

  
  let activeHeading = headings[0];
  getLinkByHeading(activeHeading).classList.add(activeClass);

  const onScroll = () => {
    const passedHeadings = [];
    for (const h of headings) {
      
      if (getOffsetTop(h) < 5) {
        passedHeadings.push(h)
      } else {
        break;
      }
    }
    if (passedHeadings.length > 0) {
      newActiveHeading = passedHeadings[passedHeadings.length - 1];
    } else {
      newActiveHeading = headings[0];
    }
    if (activeHeading != newActiveHeading) {
      getLinkByHeading(activeHeading).classList.remove(activeClass);
      activeHeading = newActiveHeading;
      getLinkByHeading(activeHeading).classList.add(activeClass);
    }
  }

  let timer = null;
  window.addEventListener('scroll', () => {
    if (timer !== null) {
      clearTimeout(timer)
    }
    timer = setTimeout(onScroll, 50)
  }, false);

  function getLinkByHeading(heading) {
    const id = encodeURI(heading.getAttribute('id')).toLowerCase();
    return document.querySelector(`.toc ul li a[href="#${id}"]`);
  }

  function getOffsetTop(heading) {
    if (!heading.getClientRects().length) {
      return 0;
    }
    let rect = heading.getBoundingClientRect();
    return rect.top
  }
}, false);
</script></body>

</html>
